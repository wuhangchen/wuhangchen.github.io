<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="C++对象模型：对象内存布局详解, C++ Linux PRC Go Docker">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48">
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7">
    <meta name="description" content="前言文章较长，而且内容相对来说比较枯燥，希望对C++对象的内存布局、虚表指针、虚基类指针等有深入了解的朋友可以慢慢看。
何为C++对象模型?引用深度探索C++对象模型这本书中的话：有两个概念可以解释C++对象模型：1、语言中直接支持面向对象">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>C++对象模型：对象内存布局详解 | 吴杭沉的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?ce84511d3df71640a9378a69f6293044";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">吴杭沉的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-comments"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">吴杭沉的博客</div>
        <div class="logo-desc">
            
            善良比聪明更重要
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-comments"></i>
                
                留言板
            </a>
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        C++对象模型：对象内存布局详解
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/C/" target="_blank">
                            <span class="chip bg-color">C++</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                        <a href="/categories/C/" class="post-category" target="_blank">
                            C++
                        </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-10-13
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    吴杭沉
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    8k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    34 分
                </div>
                
                

                
                <div id="busuanzi_container_page_pv" class="info-break-policy">
                    <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                    <span id="busuanzi_value_page_pv"></span>
                </div>
                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>文章较长，而且内容相对来说比较枯燥，希望对C++对象的内存布局、虚表指针、虚基类指针等有深入了解的朋友可以慢慢看。</p>
<h2 id="何为C-对象模型"><a href="#何为C-对象模型" class="headerlink" title="何为C++对象模型?"></a>何为C++对象模型?</h2><p>引用深度探索C++对象模型这本书中的话：<br>有两个概念可以解释C++对象模型：<br>1、语言中直接支持面向对象程序设计的部分。<br>2、对于各种支持的底层实现机制。<br>直接支持面向对象程序设计，包括了构造函数、析构函数、多态、虚函数等等，这些内容在很多书籍上都有讨论，也是C++最被人熟知的地方。而对象模型的底层实现机制却是很少有书籍讨论的。对象模型的底层实现机制并未标准化，不同的编译器有一定的自由来设计对象模型的实现细节。在我看来，对象模型研究的是对象在存储上的空间与时间上的更优，并对C++面向对象技术加以支持，如以虚指针、虚表机制支持多态特性。</p>
<h2 id="文章内容简介"><a href="#文章内容简介" class="headerlink" title="文章内容简介"></a>文章内容简介</h2><p>这篇文章主要来讨论C++对象在内存中的布局，属于第二个概念的研究范畴。而C++直接支持面向对象程序设计部分则不多讲。文章主要内容如下：<br>    • 虚函数表解析。含有虚函数或其父类含有虚函数的类，编译器都会为其添加一个虚函数表vptr，先了解虚函数表的构成，有助对C++对象模型的理解。<br>    • 虚基类表解析。虚继承产生虚基类表vbptr，虚基类表的内容与虚函数表完全不同，我们将在讲解虚继承时介绍虚函数表。<br>    • 对象模型概述：介绍简单对象模型、表格驱动对象模型，以及非继承情况下的C++对象模型。<br>    • 继承下的C++对象模型。分析C++类对象在下面情形中的内存布局：<br>1、单继承：子类单一继承自父类，分析了子类重写父类虚函数、子类定义了新的虚函数情况下子类对象内存布局。<br>2、多继承：子类继承于多个父类，分析了子类重写父类虚函数、子类定义了新的虚函数情况下子类对象内存布局，同时分析了非虚继承下的菱形继承。<br>3、虚继承：分析了单一继承下的虚继承、多重基层下的虚继承、重复继承下的虚继承。<br>    • 理解对象的内存布局之后，我们可以分析一些问题：<br>1、C++封装带来的布局成本是多大？<br>2、由空类组成的继承层次中，每个类对象的大小是多大？<br>至于其他与内存有关的知识，我假设大家都有一定的了解，如内存对齐，指针操作等。本文初看可能晦涩难懂，要求读者有一定的C++基础，对概念一有一定的掌握。</p>
<h2 id="理解虚函数表"><a href="#理解虚函数表" class="headerlink" title="理解虚函数表"></a>理解虚函数表</h2><h3 id="多态与虚表"><a href="#多态与虚表" class="headerlink" title="多态与虚表"></a>多态与虚表</h3><p>C++中虚函数的作用主要是为了实现多态机制。多态，简单来说，是指在继承层次中，父类的指针可以具有多种形态——当它指向某个子类对象时，通过它能够调用到子类的函数，而非父类的函数。</p>
<pre><code>class Base {     virtual void print(void);    }
class Drive1 :public Base{    virtual void print(void);    }
class Drive2 :public Base{    virtual void print(void);    }
Base * ptr1 = new Base;
Base * ptr2 = new Drive1;
Base * ptr3 = new Drive2;
ptr1-&gt;print();  //调用Base::print()
prt2-&gt;print();  //调用Drive1::print()
prt3-&gt;print();  //调用Drive2::print()</code></pre><p>这是一种运行期多态，即父类指针唯有在程序运行时才能知道所指的真正类型是什么。这种运行期决议，是通过虚函数表来实现的。</p>
<h3 id="使用指针访问虚表"><a href="#使用指针访问虚表" class="headerlink" title="使用指针访问虚表"></a>使用指针访问虚表</h3><p>如果我们丰富我们的Base类,使其拥有多个virtual函数：</p>
<pre><code>class Base
{
public:
    Base(int i) :baseI(i){};
    virtual void print(void){ cout &lt;&lt; &quot;调用了虚函数Base::print()&quot;; }
    virtual void setI(){cout&lt;&lt;&quot;调用了虚函数Base::setI()&quot;;}
    virtual ~Base(){}
private:
    int baseI;
};</code></pre><p>当一个类本身定义了虚函数，或其父类有虚函数时，为了支持多态机制，编译器将为该类添加一个虚函数指针（vptr）。虚函数指针一般都放在对象内存布局的第一个位置上，这是为了保证在多层继承或多重继承的情况下能以最高效率取到虚函数表。<br>当vprt位于对象内存最前面时，对象的地址即为虚函数指针地址。我们可以取得虚函数指针的地址：</p>
<pre><code>Base b(1000);
int * vptrAdree = (int *)(&amp;b);
cout &lt;&lt; &quot;虚函数指针（vprt）的地址是：\t&quot;&lt;&lt; vptrAdree &lt;&lt; endl;</code></pre><p>我们运行代码出结果：<br>我们强行把类对象的地址转换为 <code>int*</code>类型，取得了虚函数指针的地址。虚函数指针指向虚函数表,虚函数表中存储的是一系列虚函数的地址，虚函数地址出现的顺序与类中虚函数声明的顺序一致。对虚函数指针地址值，可以得到虚函数表的地址，也即是虚函数表第一个虚函数的地址:</p>
<pre><code>typedef void(*Fun)(void);
Fun vfunc = (Fun)*( (int *)*(int*)(&amp;b));
cout &lt;&lt; &quot;第一个虚函数的地址是：&quot; &lt;&lt; (int *)*(int*)(&amp;b) &lt;&lt; endl;
cout &lt;&lt; &quot;通过地址，调用虚函数Base::print()：&quot;;
vfunc();
</code></pre><pre><code>• 我们把虚表指针的值取出来：```＊(int＊)(&amp;b)```，它是一个地址，虚函数表的地址
• 把虚函数表的地址强制转换成 ```int* : ( int ＊) ＊( int＊ )( &amp;b )```
• 再把它转化成我们Fun指针类型 ：```(Fun )＊(int ＊)＊(int＊)(&amp;b)```</code></pre><p>这样，我们就取得了类中的第一个虚函数，我们可以通过函数指针访问它。<br>运行结果<br>同理,第二个虚函数setI()的地址为：</p>
<pre><code>(int * )(*(int*)(&amp;b)+1)</code></pre><p>同样可以通过函数指针访问它，这里留给读者自己试验。<br>到目前为止，我们知道了类中虚表指针vprt的由来，知道了虚函数表中的内容，以及如何通过指针访问虚函数表。下面的文章中将常使用指针访问对象内存来验证我们的C++对象模型，以及讨论在各种继承情况下虚表指针的变化，先把这部分的内容消化完再接着看下面的内容。</p>
<h2 id="对象模型概述"><a href="#对象模型概述" class="headerlink" title="对象模型概述"></a>对象模型概述</h2><p>在C++中，有两种数据成员：static 和nonstatic,以及三种类成员函数:static、nonstatic和virtual:<br>现在我们有一个类Base，它包含了上面这5中类型的数据或函数：</p>
<pre><code>class Base
{
public:
    Base(int i) :baseI(i){};
    int getI(){ return baseI; }
    static void countI(){};
    virtual ~Base(){}
    virtual void print(void){ cout &lt;&lt; &quot;Base::print()&quot;; }
private:
    int baseI;
    static int baseS;
};</code></pre><p>那么，这个类在内存中将被如何表示？5种数据都是连续存放的吗？如何布局才能支持C++多态？我们的C++标准与编译器将如何塑造出各种数据成员与成员函数呢？</p>
<h3 id="简单对象模型"><a href="#简单对象模型" class="headerlink" title="简单对象模型"></a>简单对象模型</h3><p>这个模型非常地简单粗暴。在该模型下，对象由一系列的指针组成，每一个指针都指向一个数据成员或成员函数，也即是说，每个数据成员和成员函数在类中所占的大小是相同的，都为一个指针的大小。这样有个好处——很容易算出对象的大小，不过赔上的是空间和执行期效率。想象一下，如果我们的Point3d类是这种模型，将会比C语言的struct多了许多空间来存放指向函数的指针，而且每次读取类的数据成员，都需要通过再一次寻址——又是时间上的消耗。<br>所以这种对象模型并没有被用于实际产品上。</p>
<h3 id="表格驱动模型"><a href="#表格驱动模型" class="headerlink" title="表格驱动模型"></a>表格驱动模型</h3><p>这个模型在简单对象模型的基础上又添加一个间接层，它把类中的数据分成了两个部分：数据部分与函数部分，并使用两张表格，一张存放数据本身，一张存放函数的地址，而类对象仅仅含有两个指针，分别指向上面这两个表。这样看来，对象的大小是固定为两个指针大小。这个模型也没有用于实际应用于真正的C++编译器上。</p>
<h3 id="非继承下的C-对象模型"><a href="#非继承下的C-对象模型" class="headerlink" title="非继承下的C++对象模型"></a>非继承下的C++对象模型</h3><p>概述：在此模型下，nonstatic 数据成员被置于每一个类对象中，而static数据成员被置于类对象之外。static与nonstatic函数也都放在类对象之外，而对于virtual函数，则通过虚函数表+虚指针来支持，具体如下：<br>    • 每个类生成一个表格，称为虚表virtual table，简称vtbl。虚表中存放着一堆指针，这些指针指向该类每一个虚函数。虚表中的函数地址将按声明时的顺序排列，不过当子类有多个重载函数时例外，后面会讨论。<br>    • 每个类对象都拥有一个虚表指针vptr，由编译器为其生成。虚表指针的设定与重置皆由类的复制控制也即是构造函数、析构函数、赋值操作符来完成。vptr的位置为编译器决定，传统上它被放在所有显示声明的成员之后，不过现在许多编译器把vptr放在一个类对象的最前端。关于数据成员布局的内容，在后面会详细分析。<br>另外，虚函数表的前面设置了一个指向type_info的指针，用以支持RTTI（Run Time Type Identification，运行时类型识别）。RTTI是为多态而生成的信息，包括对象继承关系，对象本身的描述等，只有具有虚函数的对象在会生成。</p>
<pre><code>Base b(1000);</code></pre><p>可见对象b含有一个vfptr，即vprt。并且只有nonstatic数据成员被放置于对象内。我们展开vfprt：<br>vfptr中有两个指针类型的数据地址，第一个指向了Base类的析构函数，第二个指向了Base的虚函数print，顺序与声明顺序相同。<br>这与上述的C++对象模型相符合。也可以通过代码来进行验证：</p>
<pre><code>void testBase(Base&amp; p)
{
    cout &lt;&lt; &quot;对象的内存起始地址：&quot; &lt;&lt; &amp;p &lt;&lt; endl;
    cout &lt;&lt; &quot;type_info信息:&quot; &lt;&lt; endl;
    RTTICompleteObjectLocator str = *((RTTICompleteObjectLocator*)*((int*)*(int*)(&amp;p) - 1));
    string classname(str.pTypeDescriptor-&gt;name);
    classname = classname.substr(4, classname.find(&quot;@@&quot;) - 4);
    cout &lt;&lt;  &quot;根据type_info信息输出类名:&quot;&lt;&lt; classname &lt;&lt; endl;
    cout &lt;&lt; &quot;虚函数表地址:&quot; &lt;&lt; (int *)(&amp;p) &lt;&lt; endl;
    //验证虚表
    cout &lt;&lt; &quot;虚函数表第一个函数的地址：&quot; &lt;&lt; (int *)*((int*)(&amp;p)) &lt;&lt; endl;
    cout &lt;&lt; &quot;析构函数的地址:&quot; &lt;&lt; (int* )*(int *)*((int*)(&amp;p)) &lt;&lt; endl;
    cout &lt;&lt; &quot;虚函数表中，第二个虚函数即print（）的地址：&quot; &lt;&lt; ((int*)*(int*)(&amp;p) + 1) &lt;&lt; endl;
    //通过地址调用虚函数print（）
    typedef void(*Fun)(void);
    Fun IsPrint=(Fun)* ((int*)*(int*)(&amp;p) + 1);
    cout &lt;&lt; endl;
    cout&lt;&lt;&quot;调用了虚函数&quot;；
    IsPrint(); //若地址正确，则调用了Base类的虚函数print（）
    cout &lt;&lt; endl;
     //输入static函数的地址
    p.countI();//先调用函数以产生一个实例
    cout &lt;&lt; &quot;static函数countI()的地址：&quot; &lt;&lt; p.countI &lt;&lt; endl;
    //验证nonstatic数据成员
    cout &lt;&lt; &quot;推测nonstatic数据成员baseI的地址：&quot; &lt;&lt; (int *)(&amp;p) + 1 &lt;&lt; endl;
    cout &lt;&lt; &quot;根据推测出的地址，输出该地址的值：&quot; &lt;&lt; *((int *)(&amp;p) + 1) &lt;&lt; endl;
    cout &lt;&lt; &quot;Base::getI():&quot; &lt;&lt; p.getI() &lt;&lt; endl;
}

Base b(1000);
testBase(b);</code></pre><p>结果分析：<br>    • 通过 <code>(int *)(&amp;p)</code>取得虚函数表的地址<br>    • type_info信息的确存在于虚表的前一个位置。通过<code>((int)(int*)(&amp;p) - 1))</code>取得type_infn信息，并成功获得类的名称的Base<br>    • 虚函数表的第一个函数是析构函数。<br>    • 虚函数表的第二个函数是虚函数<code>print()</code>，取得地址后通过地址调用它，验证正确<br>    • 虚表指针的下一个位置为nonstatic数据成员baseI。<br>    • 可以看到，static成员函数的地址段位与虚表指针、baseI的地址段位不同。<br>好的，至此我们了解了非继承下类对象五种数据在内存上的布局，也知道了在每一个虚函数表前都有一个指针指向type_info，负责对RTTI的支持。而加入继承后类对象在内存中该如何表示呢？</p>
<h2 id="继承下的C-对象模型"><a href="#继承下的C-对象模型" class="headerlink" title="继承下的C++对象模型"></a>继承下的C++对象模型</h2><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>如果我们定义了派生类。</p>
<pre><code>class Derive : public Base
{
public:
    Derive(int d) :Base(1000), DeriveI(d){};
    //overwrite父类虚函数
    virtual void print(void){cout &lt;&lt; &quot;Drive::Drive_print()&quot;;}
    // Derive声明的新的虚函数
    virtual void Drive_print(){cout &lt;&lt; &quot;Drive::Drive_print()&quot;;}
    virtual ~Derive(){}
private:
    int DeriveI;
};</code></pre><p>在C++对象模型中，对于一般继承，若子类重写overwrite了父类的虚函数，则子类虚函数将覆盖虚表中对应的父类虚函数，注意子类与父类拥有各自的一个虚函数表；若子类并无overwrite父类虚函数，而是声明了自己新的虚函数，则该虚函数地址将扩充到虚函数表最后。而对于虚继承，若子类overwrite父类虚函数，同样地将覆盖父类子物体中的虚函数表对应位置，而若子类声明了自己新的虚函数，则编译器将为子类增加一个新的虚表指针vptr，这与一般继承不同,在后面再讨论。<br>我们使用代码来验证以上模型</p>
<pre><code>typedef void(*Fun)(void);
int main()
{
    Derive d(2000);
    //[0]
    cout &lt;&lt; &quot;[0]Base::vptr&quot;;
    cout &lt;&lt; &quot;\t地址：&quot; &lt;&lt; (int *)(&amp;d) &lt;&lt; endl;
    //vprt[0]
    cout &lt;&lt; &quot;  [0]&quot;;
    Fun fun1 = (Fun)*((int *)*((int *)(&amp;d)));
    fun1();
    cout &lt;&lt; &quot;\t地址:\t&quot; &lt;&lt; *((int *)*((int *)(&amp;d))) &lt;&lt; endl;
    //vprt[1]析构函数无法通过地址调用，故手动输出
    cout &lt;&lt; &quot;  [1]&quot; &lt;&lt; &quot;Derive::~Derive&quot; &lt;&lt; endl;
    //vprt[2]
    cout &lt;&lt; &quot;  [2]&quot;;
    Fun fun2 = (Fun)*((int *)*((int *)(&amp;d)) + 2);
    fun2();
    cout &lt;&lt; &quot;\t地址:\t&quot; &lt;&lt; *((int *)*((int *)(&amp;d)) + 2) &lt;&lt; endl;
    //[1]
    cout &lt;&lt; &quot;[2]Base::baseI=&quot; &lt;&lt; *(int*)((int *)(&amp;d) + 1);
    cout &lt;&lt; &quot;\t地址：&quot; &lt;&lt; (int *)(&amp;d) + 1;
    cout &lt;&lt; endl;
    //[2]
    cout &lt;&lt; &quot;[2]Derive::DeriveI=&quot; &lt;&lt; *(int*)((int *)(&amp;d) + 2);
    cout &lt;&lt; &quot;\t地址：&quot; &lt;&lt; (int *)(&amp;d) + 2;
    cout &lt;&lt; endl;
    getchar();
}</code></pre><p>运行结果<br>这个结果与我们的对象模型符合。</p>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><h4 id="一般的多重继承非菱形继承"><a href="#一般的多重继承非菱形继承" class="headerlink" title="一般的多重继承非菱形继承"></a>一般的多重继承非菱形继承</h4><p>单继承中，子类会扩展父类的虚函数表。在多继承中，子类含有多个父类的子对象，该往哪个父类的虚函数表扩展呢？当子类overwrite了父类的函数，需要覆盖多个父类的虚函数表吗？<br>    • 子类的虚函数被放在声明的第一个基类的虚函数表中。<br>    • overwrite时，所有基类的print函数都被子类的print函数覆盖。<br>    • 内存布局中，父类按照其声明顺序排列。<br>其中第二点保证了父类指针指向子类对象时，总是能够调用到真正的函数。<br>为了方便查看，我们把代码都粘贴过来</p>
<pre><code>class Base
{
public:
    Base(int i) :baseI(i){};
    virtual ~Base(){}
    int getI(){ return baseI; }
    static void countI(){};
    virtual void print(void){ cout &lt;&lt; &quot;Base::print()&quot;; }
private:
    int baseI;
    static int baseS;
};
class Base_2
{
public:
    Base_2(int i) :base2I(i){};
    virtual ~Base_2(){}
    int getI(){ return base2I; }
    static void countI(){};
    virtual void print(void){ cout &lt;&lt; &quot;Base_2::print()&quot;; }
private:
    int base2I;
    static int base2S;
};

class Drive_multyBase :public Base, public Base_2
{
public:
    Drive_multyBase(int d) :Base(1000), Base_2(2000) ,Drive_multyBaseI(d){};
    virtual void print(void){ cout &lt;&lt; &quot;Drive_multyBase::print&quot; ; }
    virtual void Drive_print(){ cout &lt;&lt; &quot;Drive_multyBase::Drive_print&quot; ; }
private:
    int Drive_multyBaseI;
};
</code></pre><p>我们使用代码验证：</p>
<pre><code>typedef void(*Fun)(void);
int main()
{
    Drive_multyBase d(3000);
    //[0]
    cout &lt;&lt; &quot;[0]Base::vptr&quot;;
    cout &lt;&lt; &quot;\t地址：&quot; &lt;&lt; (int *)(&amp;d) &lt;&lt; endl;
    //vprt[0]析构函数无法通过地址调用，故手动输出
    cout &lt;&lt; &quot;  [0]&quot; &lt;&lt; &quot;Derive::~Derive&quot; &lt;&lt; endl;
    //vprt[1]
    cout &lt;&lt; &quot;  [1]&quot;;
    Fun fun1 = (Fun)*((int *)*((int *)(&amp;d))+1);
    fun1();
    cout &lt;&lt; &quot;\t地址:\t&quot; &lt;&lt; *((int *)*((int *)(&amp;d))+1) &lt;&lt; endl;
    //vprt[2]
    cout &lt;&lt; &quot;  [2]&quot;;
    Fun fun2 = (Fun)*((int *)*((int *)(&amp;d)) + 2);
    fun2();
    cout &lt;&lt; &quot;\t地址:\t&quot; &lt;&lt; *((int *)*((int *)(&amp;d)) + 2) &lt;&lt; endl;
    //[1]
    cout &lt;&lt; &quot;[1]Base::baseI=&quot; &lt;&lt; *(int*)((int *)(&amp;d) + 1);
    cout &lt;&lt; &quot;\t地址：&quot; &lt;&lt; (int *)(&amp;d) + 1;
    cout &lt;&lt; endl;
    //[2]
    cout &lt;&lt; &quot;[2]Base_::vptr&quot;;
    cout &lt;&lt; &quot;\t地址：&quot; &lt;&lt; (int *)(&amp;d)+2 &lt;&lt; endl;
    //vprt[0]析构函数无法通过地址调用，故手动输出
    cout &lt;&lt; &quot;  [0]&quot; &lt;&lt; &quot;Drive_multyBase::~Derive&quot; &lt;&lt; endl;
    //vprt[1]
    cout &lt;&lt; &quot;  [1]&quot;;
    Fun fun4 = (Fun)*((int *)*((int *)(&amp;d))+1);
    fun4();
    cout &lt;&lt; &quot;\t地址:\t&quot; &lt;&lt; *((int *)*((int *)(&amp;d))+1) &lt;&lt; endl;
    //[3]
    cout &lt;&lt; &quot;[3]Base_2::base2I=&quot; &lt;&lt; *(int*)((int *)(&amp;d) + 3);
    cout &lt;&lt; &quot;\t地址：&quot; &lt;&lt; (int *)(&amp;d) + 3;
    cout &lt;&lt; endl;
    //[4]
    cout &lt;&lt; &quot;[4]Drive_multyBase::Drive_multyBaseI=&quot; &lt;&lt; *(int*)((int *)(&amp;d) + 4);
    cout &lt;&lt; &quot;\t地址：&quot; &lt;&lt; (int *)(&amp;d) + 4;
    cout &lt;&lt; endl;
    getchar();
}
</code></pre><p>运行结果</p>
<h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><p>菱形继承也称为钻石型继承或重复继承，它指的是基类被某个派生类简单重复继承了多次。这样，派生类对象中拥有多份基类实例。为了方便叙述，我们不使用上面的代码了，而重新写一个重复继承的继承层次：</p>
<pre><code>class B
{
public:
    int ib;
public:
    B(int i=1) :ib(i){}
    virtual void f() { cout &lt;&lt; &quot;B::f()&quot; &lt;&lt; endl; }
    virtual void Bf() { cout &lt;&lt; &quot;B::Bf()&quot; &lt;&lt; endl; }
};
class B1 : public B
{
public:
    int ib1;
public:
    B1(int i = 100 ) :ib1(i) {}
    virtual void f() { cout &lt;&lt; &quot;B1::f()&quot; &lt;&lt; endl; }
    virtual void f1() { cout &lt;&lt; &quot;B1::f1()&quot; &lt;&lt; endl; }
    virtual void Bf1() { cout &lt;&lt; &quot;B1::Bf1()&quot; &lt;&lt; endl; }
};
class B2 : public B
{
public:
    int ib2;
public:
    B2(int i = 1000) :ib2(i) {}
    virtual void f() { cout &lt;&lt; &quot;B2::f()&quot; &lt;&lt; endl; }
    virtual void f2() { cout &lt;&lt; &quot;B2::f2()&quot; &lt;&lt; endl; }
    virtual void Bf2() { cout &lt;&lt; &quot;B2::Bf2()&quot; &lt;&lt; endl; }
};
class D : public B1, public B2
{
public:
    int id;
public:
    D(int i= 10000) :id(i){}
    virtual void f() { cout &lt;&lt; &quot;D::f()&quot; &lt;&lt; endl; }
    virtual void f1() { cout &lt;&lt; &quot;D::f1()&quot; &lt;&lt; endl; }
    virtual void f2() { cout &lt;&lt; &quot;D::f2()&quot; &lt;&lt; endl; }
    virtual void Df() { cout &lt;&lt; &quot;D::Df()&quot; &lt;&lt; endl; }
};</code></pre><p>这时，根据单继承，我们可以分析出B1，B2类继承于B类时的内存布局。又根据一般多继承，我们可以分析出D类的内存布局。我们可以得出D类子对象的内存布局如下图</p>
<pre><code>D d;
d.ib =1 ;               //二义性错误,调用的是B1的ib还是B2的ib？
d.B1::ib = 1;           //正确
d.B2::ib = 1;           //正确</code></pre><p>尽管我们可以通过明确指明调用路径以消除二义性，但二义性的潜在性还没有消除，我们可以通过虚继承来使D类只拥有一个ib实体。</p>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虚继承解决了菱形继承中派生类拥有多个间接父类实例的情况。虚继承的派生类的内存布局与普通继承很多不同，主要体现在：虚继承的子类，如果本身定义了新的虚函数，则编译器为其生成一个虚函数指针以及一张虚函数表。该vptr位于对象内存最前面。<br>    • vs非虚继承：直接扩展父类虚函数表。<br>    虚继承的子类也单独保留了父类的vprt与虚函数表。这部分内容接与子类内容以一个四字节的0来分界。<br>    • 虚继承的子类对象中，含有四字节的虚表指针偏移值。<br>为了分析最后的菱形继承，我们还是先从单虚继承继承开始。</p>
<h4 id="虚基类表解析"><a href="#虚基类表解析" class="headerlink" title="虚基类表解析"></a>虚基类表解析</h4><p>在C++对象模型中，虚继承而来的子类会生成一个隐藏的虚基类指针vbptr，在Microsoft Visual C++中，虚基类表指针总是在虚函数表指针之后，因而，对某个类实例来说，如果它有虚基类指针，那么虚基类指针可能在实例的0字节偏移处,该类没有vptr时，vbptr就处于类实例内存布局的最前面，否则vptr处于类实例内存布局的最前面，也可能在类实例的4字节偏移处。<br>一个类的虚基类指针指向的虚基类表，与虚函数表一样，虚基类表也由多个条目组成，条目中存放的是偏移值。第一个条目存放虚基类表指针vbptr所在地址到该类内存首地址的偏移值，由第一段的分析我们知道，这个偏移值为0类没有vptr或者4类有虚函数，此时有vptr。我们通过一张图来更好地理解。<br>虚基类表的第二、第三…个条目依次为该类的最左虚继承父类、次左虚继承父类…的内存地址相对于虚基类表指针的偏移值，这点我们在下面会验证。</p>
<h4 id="简单虚继承"><a href="#简单虚继承" class="headerlink" title="简单虚继承"></a>简单虚继承</h4><p>如果我们的B1类虚继承于B类：</p>
<pre><code>//类的内容与前面相同
class B{...}
class B1 : virtual public B</code></pre><p>根据我们前面对虚继承的派生类的内存布局的分析，B1类的对象模型应该是这样的</p>
<p>我们通过指针访问B1类对象的内存，以验证上面的C++对象模型：</p>
<pre><code>int main()
{
    B1 a;
    cout &lt;&lt;&quot;B1对象内存大小为：&quot;&lt;&lt; sizeof(a) &lt;&lt; endl;
    //取得B1的虚函数表
    cout &lt;&lt; &quot;[0]B1::vptr&quot;;
    cout &lt;&lt; &quot;\t地址：&quot; &lt;&lt; (int *)(&amp;a)&lt;&lt; endl;

    //输出虚表B1::vptr中的函数
    for (int i = 0; i&lt;2;++ i)
    {
        cout &lt;&lt; &quot;  [&quot; &lt;&lt; i &lt;&lt; &quot;]&quot;;
        Fun fun1 = (Fun)*((int *)*(int *)(&amp;a) + i);
        fun1();
        cout &lt;&lt; &quot;\t地址：\t&quot; &lt;&lt; *((int *)*(int *)(&amp;a) + i) &lt;&lt; endl;
    }
    //[1]
    cout &lt;&lt; &quot;[1]vbptr &quot;  ;
    cout&lt;&lt;&quot;\t地址：&quot; &lt;&lt; (int *)(&amp;a) + 1&lt;&lt;endl;  //虚表指针的地址
    //输出虚基类指针条目所指的内容
    for (int i = 0; i &lt; 2; i++)
    {
        cout &lt;&lt; &quot;  [&quot; &lt;&lt; i &lt;&lt; &quot;]&quot;;
        cout &lt;&lt; *(int *)((int *)*((int *)(&amp;a) + 1) + i);
        cout &lt;&lt; endl;
    }
    //[2]
    cout &lt;&lt; &quot;[2]B1::ib1=&quot; &lt;&lt; *(int*)((int *)(&amp;a) + 2);
    cout &lt;&lt; &quot;\t地址：&quot; &lt;&lt; (int *)(&amp;a) + 2;
    cout &lt;&lt; endl;
    //[3]
    cout &lt;&lt; &quot;[3]值=&quot; &lt;&lt; *(int*)((int *)(&amp;a) + 3);
    cout &lt;&lt; &quot;\t\t地址：&quot; &lt;&lt; (int *)(&amp;a) + 3;
    cout &lt;&lt; endl;
    //[4]
    cout &lt;&lt; &quot;[4]B::vptr&quot;;
    cout &lt;&lt; &quot;\t地址：&quot; &lt;&lt; (int *)(&amp;a) +3&lt;&lt; endl;
    //输出B::vptr中的虚函数
    for (int i = 0; i&lt;2; ++i)
    {
        cout &lt;&lt; &quot;  [&quot; &lt;&lt; i &lt;&lt; &quot;]&quot;;
        Fun fun1 = (Fun)*((int *)*((int *)(&amp;a) + 4) + i);
        fun1();
        cout &lt;&lt; &quot;\t地址:\t&quot; &lt;&lt; *((int *)*((int *)(&amp;a) + 4) + i) &lt;&lt; endl;
    }
    //[5]
    cout &lt;&lt; &quot;[5]B::ib=&quot; &lt;&lt; *(int*)((int *)(&amp;a) + 5);
    cout &lt;&lt; &quot;\t地址: &quot; &lt;&lt; (int *)(&amp;a) + 5;
    cout &lt;&lt; endl;
}</code></pre><p>这个结果与我们的C++对象模型图完全符合。这时我们可以来分析一下虚表指针的第二个条目值12的具体来源了，回忆上文讲到的：<br>第二、第三…个条目依次为该类的最左虚继承父类、次左虚继承父类…的内存地址相对于虚基类表指针的偏移值。<br>在我们的例子中，也就是B类实例内存地址相对于vbptr的偏移值，也即是：[4]-[1]的偏移值，结果即为12，从地址上也可以计算出来：007CFDFC-007CFDF4结果的十进制数正是12。现在，我们对虚基类表的构成应该有了一个更好的理解。</p>
<h4 id="虚拟菱形继承"><a href="#虚拟菱形继承" class="headerlink" title="虚拟菱形继承"></a>虚拟菱形继承</h4><p>如果我们有如下继承层次：</p>
<pre><code>class B{...}
class B1: virtual public  B{...}
class B2: virtual public  B{...}
class D : public B1,public B2{...}</code></pre><p>菱形虚拟继承下，最派生类D类的对象模型又有不同的构成了。在D类对象的内存构成上，有以下几点：<br>    • 在D类对象内存中，基类出现的顺序是：先是B1（最左父类），然后是B2（次左父类），最后是B（虚祖父类）<br>    • D类对象的数据成员id放在B类前面，两部分数据依旧以0来分隔。<br>    • 编译器没有为D类生成一个它自己的vptr，而是覆盖并扩展了最左父类的虚基类表，与简单继承的对象模型相同。<br>    • 超类B的内容放到了D类对象内存布局的最后。<br>下面使用代码加以验证：</p>
<pre><code>int main()
{
    D d;
    cout &lt;&lt; &quot;D对象内存大小为：&quot; &lt;&lt; sizeof(d) &lt;&lt; endl;
    //取得B1的虚函数表
    cout &lt;&lt; &quot;[0]B1::vptr&quot;;
    cout &lt;&lt; &quot;\t地址：&quot; &lt;&lt; (int *)(&amp;d) &lt;&lt; endl;
    //输出虚表B1::vptr中的函数
    for (int i = 0; i&lt;3; ++i)
    {
        cout &lt;&lt; &quot;  [&quot; &lt;&lt; i &lt;&lt; &quot;]&quot;;
        Fun fun1 = (Fun)*((int *)*(int *)(&amp;d) + i);
        fun1();
        cout &lt;&lt; &quot;\t地址：\t&quot; &lt;&lt; *((int *)*(int *)(&amp;d) + i) &lt;&lt; endl;
    }
    //[1]
    cout &lt;&lt; &quot;[1]B1::vbptr &quot;;
    cout &lt;&lt; &quot;\t地址：&quot; &lt;&lt; (int *)(&amp;d) + 1 &lt;&lt; endl;  //虚表指针的地址
    //输出虚基类指针条目所指的内容
    for (int i = 0; i &lt; 2; i++)
    {
        cout &lt;&lt; &quot;  [&quot; &lt;&lt; i &lt;&lt; &quot;]&quot;;
        cout &lt;&lt; *(int *)((int *)*((int *)(&amp;d) + 1) + i);
        cout &lt;&lt; endl;
    }
    //[2]
    cout &lt;&lt; &quot;[2]B1::ib1=&quot; &lt;&lt; *(int*)((int *)(&amp;d) + 2);
    cout &lt;&lt; &quot;\t地址：&quot; &lt;&lt; (int *)(&amp;d) + 2;
    cout &lt;&lt; endl;
    //[3]
    cout &lt;&lt; &quot;[3]B2::vptr&quot;;
    cout &lt;&lt; &quot;\t地址：&quot; &lt;&lt; (int *)(&amp;d) + 3 &lt;&lt; endl;
    //输出B2::vptr中的虚函数
    for (int i = 0; i&lt;2; ++i)
    {
        cout &lt;&lt; &quot;  [&quot; &lt;&lt; i &lt;&lt; &quot;]&quot;;
        Fun fun1 = (Fun)*((int *)*((int *)(&amp;d) + 3) + i);
        fun1();
        cout &lt;&lt; &quot;\t地址:\t&quot; &lt;&lt; *((int *)*((int *)(&amp;d) + 3) + i) &lt;&lt; endl;
    }
    //[4]
    cout &lt;&lt; &quot;[4]B2::vbptr &quot;;
    cout &lt;&lt; &quot;\t地址：&quot; &lt;&lt; (int *)(&amp;d) + 4 &lt;&lt; endl;  //虚表指针的地址
    //输出虚基类指针条目所指的内容
    for (int i = 0; i &lt; 2; i++)
    {
        cout &lt;&lt; &quot;  [&quot; &lt;&lt; i &lt;&lt; &quot;]&quot;;
        cout &lt;&lt; *(int *)((int *)*((int *)(&amp;d) + 4) + i);
        cout &lt;&lt; endl;
    }
    //[5]
    cout &lt;&lt; &quot;[5]B2::ib2=&quot; &lt;&lt; *(int*)((int *)(&amp;d) + 5);
    cout &lt;&lt; &quot;\t地址: &quot; &lt;&lt; (int *)(&amp;d) + 5;
    cout &lt;&lt; endl;
    //[6]
    cout &lt;&lt; &quot;[6]D::id=&quot; &lt;&lt; *(int*)((int *)(&amp;d) + 6);
    cout &lt;&lt; &quot;\t地址: &quot; &lt;&lt; (int *)(&amp;d) + 6;
    cout &lt;&lt; endl;
    //[7]
    cout &lt;&lt; &quot;[7]值=&quot; &lt;&lt; *(int*)((int *)(&amp;d) + 7);
    cout &lt;&lt; &quot;\t\t地址：&quot; &lt;&lt; (int *)(&amp;d) + 7;
    cout &lt;&lt; endl;
    //间接父类
    //[8]
    cout &lt;&lt; &quot;[8]B::vptr&quot;;
    cout &lt;&lt; &quot;\t地址：&quot; &lt;&lt; (int *)(&amp;d) + 8 &lt;&lt; endl;
    //输出B::vptr中的虚函数
    for (int i = 0; i&lt;2; ++i)
    {
        cout &lt;&lt; &quot;  [&quot; &lt;&lt; i &lt;&lt; &quot;]&quot;;
        Fun fun1 = (Fun)*((int *)*((int *)(&amp;d) + 8) + i);
        fun1();
        cout &lt;&lt; &quot;\t地址:\t&quot; &lt;&lt; *((int *)*((int *)(&amp;d) + 8) + i) &lt;&lt; endl;
    }
    //[9]
    cout &lt;&lt; &quot;[9]B::id=&quot; &lt;&lt; *(int*)((int *)(&amp;d) + 9);
    cout &lt;&lt; &quot;\t地址: &quot; &lt;&lt; (int *)(&amp;d) +9;
    cout &lt;&lt; endl;
    getchar();
}
</code></pre><h2 id="一些问题解答"><a href="#一些问题解答" class="headerlink" title="一些问题解答"></a>一些问题解答</h2><h3 id="C-封装带来的布局成本是多大？"><a href="#C-封装带来的布局成本是多大？" class="headerlink" title="C++封装带来的布局成本是多大？"></a>C++封装带来的布局成本是多大？</h3><p>在C语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。<br>在C++中，我们通过类来将属性与操作绑定在一起，称为ADT，抽象数据结构。<br>C语言中使用struct来封装数据，使用函数来处理数据。举个例子，如果我们定义了一个struct Point3如下：</p>
<pre><code>typedef struct Point3
{
    float x;
    float y;
    float z;
} Point3;
</code></pre><p>为了打印这个Point3d，我们可以定义一个函数：</p>
<pre><code>void Point3d_print(const Point3d *pd)
{
    printf(&quot;(%f,%f,%f)&quot;,pd-&gt;x,pd-&gt;y,pd_z);
}</code></pre><p>而在C++中，我们更倾向于定义一个Point3d类，以ADT来实现上面的操作:</p>
<pre><code>class Point3d
{
    public:
        point3d (float x = 0.0,float y = 0.0,float z = 0.0)
            : _x(x), _y(y), _z(z){}

        float x() const {return _x;}
        float y() const {return _y;}
        float z() const {return _z;}
    private:
        float _x;
        float _y;
        float _z;
}；

inline ostream&amp; operator&lt;&lt;(ostream &amp;os, const Point3d &amp;pt)
{
    os&lt;&lt;&quot;(&quot;&lt;&lt;pr.x()&lt;&lt;&quot;,&quot;
            &lt;&lt;pt.y()&lt;&lt;&quot;,&quot;&lt;&lt;pt.z()&lt;&lt;&quot;)&quot;;
}</code></pre><p>看到这段代码，很多人第一个疑问可能是：加上了封装，布局成本增加了多少？答案是<code>class Point3d</code>并没有增加成本。学过了C++对象模型，我们知道，<code>Point3d</code>类对象的内存中，只有三个数据成员。<br>上面的类声明中，三个数据成员直接内含在每一个<code>Point3d</code>对象中，而成员函数虽然在类中声明，却不出现在类对象object之中，这些函数non-inline属于类而不属于类对象，只会为类产生唯一的函数实例。<br>所以，<code>Point3d</code>的封装并没有带来任何空间或执行期的效率影响。而在下面这种情况下，C++的封装额外成本才会显示出来：<br>    • 虚函数机制virtual function , 用以支持执行期绑定，实现多态。<br>    • 虚基类 virtual base class ，虚继承关系产生虚基类，用于在多重继承下保证基类在子类中拥有唯一实例。<br>不仅如此，<code>Point3d</code>类数据成员的内存布局与c语言的结构体<code>Point3d</code>成员内存布局是相同的。C++中处在同一个访问标识符指public、private、protected下的声明的数据成员，在内存中必定保证以其声明顺序出现。而处于不同访问标识符声明下的成员则无此规定。对于<code>Point3</code>类来说，它的三个数据成员都处于<code>private</code>下，在内存中一起声明顺序出现。我们可以做下实验：</p>
<pre><code>void TestPoint3Member(const Point3d&amp; p)
{
    cout &lt;&lt; &quot;推测_x的地址是：&quot; &lt;&lt; (float *) (&amp;p) &lt;&lt; endl;
    cout &lt;&lt; &quot;推测_y的地址是：&quot; &lt;&lt; (float *) (&amp;p) + 1 &lt;&lt; endl;
    cout &lt;&lt; &quot;推测_z的地址是：&quot; &lt;&lt; (float *) (&amp;p) + 2 &lt;&lt; endl;
    cout &lt;&lt; &quot;根据推测出的地址输出_x的值：&quot; &lt;&lt; *((float *)(&amp;p)) &lt;&lt; endl;
    cout &lt;&lt; &quot;根据推测出的地址输出_y的值：&quot; &lt;&lt; *((float *)(&amp;p)+1) &lt;&lt; endl;
    cout &lt;&lt; &quot;根据推测出的地址输出_z的值：&quot; &lt;&lt; *((float *)(&amp;p)+2) &lt;&lt; endl;
}</code></pre><p>运行结果：<br>从结果可以看到，_x,_y,_z三个数据成员在内存中紧挨着。</p>
<h3 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h3><p>不考虑虚函数与虚继承，当数据都在同一个访问标识符下，C++的类与C语言的结构体在对象大小和内存布局上是一致的，C++的封装并没有带来空间时间上的影响。</p>
<h3 id="下面这个空类构成的继承层次中，每个类的大小是多少？"><a href="#下面这个空类构成的继承层次中，每个类的大小是多少？" class="headerlink" title="下面这个空类构成的继承层次中，每个类的大小是多少？"></a>下面这个空类构成的继承层次中，每个类的大小是多少？</h3><p>今有类如下：</p>
<pre><code>class B{};
class B1 :public virtual  B{};
class B2 :public virtual  B{};
class D : public B1, public B2{};

int main()
{
    B b;
    B1 b1;
    B2 b2;
    D d;
    cout &lt;&lt; &quot;sizeof(b)=&quot; &lt;&lt; sizeof(b)&lt;&lt;endl;
    cout &lt;&lt; &quot;sizeof(b1)=&quot; &lt;&lt; sizeof(b1) &lt;&lt; endl;
    cout &lt;&lt; &quot;sizeof(b2)=&quot; &lt;&lt; sizeof(b2) &lt;&lt; endl;
    cout &lt;&lt; &quot;sizeof(d)=&quot; &lt;&lt; sizeof(d) &lt;&lt; endl;
    getchar();
}</code></pre><p>输出结果是：<br>解析：<br>    • 编译器为空类安插1字节的char，以使该类对象在内存得以配置一个地址。<br>    • b1虚继承于b，编译器为其安插一个4字节的虚基类表指针32为机器，此时b1已不为空，编译器不再为其安插1字节的char优化。<br>    • b2同理。<br>    • d含有来自b1与b2两个父类的两个虚基类表指针。大小为8字节。</p>

            </div>
            <hr />

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《C++对象模型：对象内存布局详解》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2024/10/13/fortyone/" property="cc:attributionName"
               rel="cc:attributionURL">
                吴杭沉
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
    <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '查教程获取',
        clientSecret: '查教程获取',
        repo: 'wuhangchen.github.io',
        owner: 'wuhangchen',
        admin: "wuhangchen",
        id: '2024/10/13/fortyone/',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    
    <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script> -->

<script>
    new Valine({
        el: '#vcomments',
        appId: '查教程获取',
        appKey: '查教程获取',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'wavatar',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '如果你没有GitHub账号，还可以在这里评论啦！'
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/10/29/fortytwo/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/24.jpg" class="responsive-img" alt="C++ 静态库与动态库">
                        
                        <span class="card-title">C++ 静态库与动态库</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            这次分享的宗旨是——让大家学会创建与使用静态库、动态库，知道静态库与动态库的区别，知道使用的时候如何选择。这里不深入介绍静态库、动态库的底层格式，内存布局等，有兴趣的同学，推荐一本书《程序员的自我修养——链接、装载与库》。库是写好的现有的，
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2024-10-29
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/C/" class="post-category" target="_blank">
                                    C++
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/C/" target="_blank">
                        <span class="chip bg-color">C++</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/10/13/forty/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/22.jpg" class="responsive-img" alt="C/C++整型变量赋值操作是原子性的吗？">
                        
                        <span class="card-title">C/C++整型变量赋值操作是原子性的吗？</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            整型变量赋值操作不是原子操作那么为什么整型变量的操作不是原子性的呢？常见的整型变量操作有如下几种情况：给整型变量赋值一个确定的值，如
int a = 1;这条指令操作一般是原子的，因为对应着一条计算机指令，cpu将立即数1搬运到变量a的内存
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2024-10-13
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/C/" class="post-category" target="_blank">
                                    C++
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/C/" target="_blank">
                        <span class="chip bg-color">C++</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 吴杭沉的博客<br />'
            + '作者: 吴杭沉<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2017-2024 Wuhangchen. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">69.3k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
            <br>
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                <i class="fa fa-heart-o"></i>
                本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <span id="busuanzi_container_site_uv" style='display:none'>
                人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
            </span>
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/wuhangchen" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:codewu1996@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="https://zhihu.com/people/wuhangchen" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-inverse">知</i>
    </a>



    <a href="http://wpa.qq.com/msgrd?v=3&uin=1714593434&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>





    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 80000;
        var uvcountOffset = 20000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2017, 09, 11, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=查教程获取"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '查教程获取');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    <!-- 雪花特效 -->
    
    <script type="text/javascript" src="/libs/others/snow.js"></script>
    

</body>

</html>