<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吴杭沉的博客</title>
  
  <subtitle>小吴同学</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="localhost/"/>
  <updated>2025-08-23T10:06:07.544Z</updated>
  <id>localhost/</id>
  
  <author>
    <name>吴杭沉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux-netstat</title>
    <link href="localhost/2025/08/19/linux-netstat/"/>
    <id>localhost/2025/08/19/linux-netstat/</id>
    <published>2025-08-19T14:01:50.000Z</published>
    <updated>2025-08-23T10:06:07.544Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface
        
      
    
    </summary>
    
      <category term="Linux" scheme="localhost/categories/Linux/"/>
    
    
      <category term="Linux" scheme="localhost/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux-动态链接与静态链接</title>
    <link href="localhost/2025/08/19/linux-dong-tai-lian-jie-yu-jing-tai-lian-jie/"/>
    <id>localhost/2025/08/19/linux-dong-tai-lian-jie-yu-jing-tai-lian-jie/</id>
    <published>2025-08-19T13:51:41.000Z</published>
    <updated>2025-08-19T13:53:26.251Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。&lt;br&gt;本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种：静态库（.a、.lib）和动态库（.so、.dl
        
      
    
    </summary>
    
      <category term="Linux" scheme="localhost/categories/Linux/"/>
    
    
      <category term="Linux" scheme="localhost/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux-nc</title>
    <link href="localhost/2025/08/16/linux-nc/"/>
    <id>localhost/2025/08/16/linux-nc/</id>
    <published>2025-08-16T09:28:24.000Z</published>
    <updated>2025-08-16T10:26:02.507Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;Netcat 号称 TCP/IP 的瑞士军刀并非浪得虚名，以体积小（可执行 200KB）功能灵活而著称，在各大发行版中都默认安装，你可以用它来做很多网络相关的工作，熟练使用它可以不依靠其他工具做一些很有用的事情。最初作者是叫做“霍比特人”的网友 Hobbit &lt;a
        
      
    
    </summary>
    
      <category term="Linux" scheme="localhost/categories/Linux/"/>
    
    
      <category term="Linux" scheme="localhost/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux-fork-interview</title>
    <link href="localhost/2025/08/14/linux-fork-interview/"/>
    <id>localhost/2025/08/14/linux-fork-interview/</id>
    <published>2025-08-14T13:14:01.000Z</published>
    <updated>2025-08-14T13:24:04.837Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;前两天有人问了个关于Unix的fork()系统调用的面试题，这个题正好是我大约十年前找工作时某公司问我的一个题，我觉得比较有趣，写篇文章与大家分享一下。这个题是这样的：&lt;br&gt;每一轮&lt;code&gt;fork&lt;/code&gt;操作产生的新进程数量是当前正在运行的进程数量。&lt;br&gt;题目
        
      
    
    </summary>
    
      <category term="Linux" scheme="localhost/categories/Linux/"/>
    
    
      <category term="Linux" scheme="localhost/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux-fork-clone</title>
    <link href="localhost/2025/08/14/linux-fork-clone/"/>
    <id>localhost/2025/08/14/linux-fork-clone/</id>
    <published>2025-08-14T12:56:25.000Z</published>
    <updated>2025-08-14T13:13:27.411Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;在本文中，传统UNIX fork之后，我给出传统的UNIX fork在Linux内核中的变体clone系统调用的精彩。&lt;br&gt;若要理解fork的原始意义，还是要看Melvin Conway提出fork思想的原始论文 A Multiprocessor System
        
      
    
    </summary>
    
      <category term="Linux" scheme="localhost/categories/Linux/"/>
    
    
      <category term="Linux" scheme="localhost/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux-fork-risk</title>
    <link href="localhost/2025/08/12/linux-fork-risk/"/>
    <id>localhost/2025/08/12/linux-fork-risk/</id>
    <published>2025-08-12T12:59:47.000Z</published>
    <updated>2025-08-14T13:07:06.788Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;fork是一个拥有50年历史的陈年系统调用，它是一个传奇！时至今日，它依旧灿烂。&lt;br&gt;一个程序员可以永远不用read/write，也可以不懂mmap，但必须懂fork。这是一种格调！&lt;br&gt;fork没有参数，它是如此简单，是UNIX哲学的布道者或者说卫道者们的首选，它被写
        
      
    
    </summary>
    
      <category term="Linux" scheme="localhost/categories/Linux/"/>
    
    
      <category term="Linux" scheme="localhost/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux-fork-Pre</title>
    <link href="localhost/2025/08/12/linux-fork-pre/"/>
    <id>localhost/2025/08/12/linux-fork-pre/</id>
    <published>2025-08-12T12:56:35.000Z</published>
    <updated>2025-08-12T12:59:20.036Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;fork的思想在UNIX出现几年前就出现了，时间大概是1963年，这比UNIX在PDP-7上的第一个版本早了6年。&lt;br&gt;1963年，计算机科学家Melvin Conway(以Conway’s Law闻名于世)写下一篇论文，正式提出了fork思想，该论文链接：&lt;br&gt;A
        
      
    
    </summary>
    
      <category term="Linux" scheme="localhost/categories/Linux/"/>
    
    
      <category term="Linux" scheme="localhost/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 数据类型 json </title>
    <link href="localhost/2025/06/08/linux-shu-ju-lei-xing-json/"/>
    <id>localhost/2025/06/08/linux-shu-ju-lei-xing-json/</id>
    <published>2025-06-08T14:23:55.000Z</published>
    <updated>2025-08-12T12:50:06.488Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;前几天，我才知道有一种简化的数据交换格式，叫做yaml。我翻了一遍它的文档，看懂的地方不多，但是有一句话令我茅塞顿开。&lt;br&gt;它说，从结构上看，所有的数据（data）最终都可以分解成三种类型：&lt;br&gt;第一种类型是标量（scalar），也就是一个单独的字符串（string）或
        
      
    
    </summary>
    
      <category term="Linux" scheme="localhost/categories/Linux/"/>
    
    
      <category term="Linux+" scheme="localhost/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>右值引用</title>
    <link href="localhost/2024/11/03/fortyfour/"/>
    <id>localhost/2024/11/03/fortyfour/</id>
    <published>2024-11-03T05:36:56.000Z</published>
    <updated>2025-04-21T14:00:17.441Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="C++" scheme="localhost/categories/C/"/>
    
    
      <category term="C++" scheme="localhost/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++工程实践</title>
    <link href="localhost/2024/10/30/fortythree/"/>
    <id>localhost/2024/10/30/fortythree/</id>
    <published>2024-10-30T12:45:13.000Z</published>
    <updated>2025-05-06T13:42:07.858Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;什么是值语义&quot;&gt;&lt;a href=&quot;#什么是值语义&quot; class=&quot;headerlink&quot; title=&quot;什么是值语义&quot;&gt;&lt;/a&gt;什么是值语义&lt;/h2&gt;&lt;p&gt;值语义指的是对象的拷贝与原对象无关，就像拷贝 &lt;code&gt;int&lt;/code&gt;一样。C++
        
      
    
    </summary>
    
      <category term="C++" scheme="localhost/categories/C/"/>
    
    
      <category term="C++" scheme="localhost/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 静态库与动态库</title>
    <link href="localhost/2024/10/29/c-bian-yi/"/>
    <id>localhost/2024/10/29/c-bian-yi/</id>
    <published>2024-10-29T13:21:55.000Z</published>
    <updated>2025-05-06T13:50:29.078Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;这次分享的宗旨是——让大家学会创建与使用静态库、动态库，知道静态库与动态库的区别，知道使用的时候如何选择。这里不深入介绍静态库、动态库的底层格式，内存布局等，有兴趣的同学，推荐一本书《程序员的自我修养——链接、装载与库》。&lt;br&gt;库是写好的现有的，成熟的，可以复用的代码。现
        
      
    
    </summary>
    
      <category term="C++" scheme="localhost/categories/C/"/>
    
    
      <category term="C++" scheme="localhost/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++对象模型：对象内存布局详解</title>
    <link href="localhost/2024/10/13/fortyone/"/>
    <id>localhost/2024/10/13/fortyone/</id>
    <published>2024-10-13T09:41:08.000Z</published>
    <updated>2025-04-21T14:23:25.087Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这篇文章希望对C++对象的内存布局、虚表指针、虚基类指针等有深入介绍。&lt;/p&gt;
&lt;h2 id=&quot;何为C-对象模型&quot;&gt;&lt;a
        
      
    
    </summary>
    
      <category term="C++" scheme="localhost/categories/C/"/>
    
    
      <category term="C++" scheme="localhost/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C/C++整型变量赋值操作是原子性的吗？</title>
    <link href="localhost/2024/10/13/c-yuan-zi-bian-liang/"/>
    <id>localhost/2024/10/13/c-yuan-zi-bian-liang/</id>
    <published>2024-10-13T09:23:32.000Z</published>
    <updated>2025-04-21T13:40:31.911Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;那么为什么整型变量的操作不是原子性的呢？常见的整型变量操作有如下几种情况：&lt;br&gt;给整型变量赋值一个确定的值，如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a =
        
      
    
    </summary>
    
      <category term="C++" scheme="localhost/categories/C/"/>
    
    
      <category term="C++" scheme="localhost/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>so出现undefined symbol------ldd, nm, c++filt</title>
    <link href="localhost/2024/10/08/thirtynine/"/>
    <id>localhost/2024/10/08/thirtynine/</id>
    <published>2024-10-08T13:51:15.000Z</published>
    <updated>2025-05-08T13:42:30.665Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;最近发版本，灰度发布的时候，发现进程没起来，回包自然是异常的。立即进行版本回退，发现OK.&lt;br&gt;哪里出问题了呢？ 直接&lt;code&gt;ldd -r
        
      
    
    </summary>
    
      <category term="C++" scheme="localhost/categories/C/"/>
    
    
      <category term="C++" scheme="localhost/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Lambda 表达式捕获列表</title>
    <link href="localhost/2024/10/08/thirtyeight/"/>
    <id>localhost/2024/10/08/thirtyeight/</id>
    <published>2024-10-08T13:47:07.000Z</published>
    <updated>2025-05-08T13:37:42.466Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;捕获值列表，是允许我们在Lambda表达式的函数体中直接使用这些值，捕获值列表能捕获的值是所有在此作用域可以访问的值，包括这个作用域里面的临时变量，类的可访问成员，全局变量。捕获值的方式分两种，一种是按值捕获，一种是按引用捕获。顾名思义，按值捕获是不改变原有变量的值，按引用
        
      
    
    </summary>
    
      <category term="C++" scheme="localhost/categories/C/"/>
    
    
      <category term="C++" scheme="localhost/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>内存分配malloc</title>
    <link href="localhost/2024/10/08/thirtyseven/"/>
    <id>localhost/2024/10/08/thirtyseven/</id>
    <published>2024-10-08T13:25:39.000Z</published>
    <updated>2025-05-13T13:36:53.485Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;下面的代码片段输出是什么？为什么？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char *ptr;
if((ptr = (char *)malloc(0)) == NULL)
    puts(&amp;quot;Got a null pointer&amp;quot;);
else
   
        
      
    
    </summary>
    
      <category term="C++" scheme="localhost/categories/C/"/>
    
    
      <category term="C++" scheme="localhost/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++成员修饰const和mutable</title>
    <link href="localhost/2024/09/28/thirtysex/"/>
    <id>localhost/2024/09/28/thirtysex/</id>
    <published>2024-09-28T10:07:45.000Z</published>
    <updated>2025-05-13T13:38:30.458Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;code&gt;const&lt;/code&gt;：常量，不变的&lt;br&gt;&lt;code&gt;mutable&lt;/code&gt;：易变的&lt;br&gt;从意思上理解，可见&lt;code&gt;const&lt;/code&gt;和&lt;code&gt;mutable&lt;/code&gt;是一对反义词，它们都是C++的关键字。&lt;br&gt;&lt;code&gt;con
        
      
    
    </summary>
    
      <category term="C++" scheme="localhost/categories/C/"/>
    
    
      <category term="C++" scheme="localhost/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>使用++i还是i++</title>
    <link href="localhost/2024/09/25/thirtyfive/"/>
    <id>localhost/2024/09/25/thirtyfive/</id>
    <published>2024-09-25T14:47:51.000Z</published>
    <updated>2025-05-08T13:38:51.215Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;我们经常使用&lt;code&gt;for&lt;/code&gt;循环来遍历东西，循环变量可以前自增也可以后自增，发现对遍历结果没啥影响，但是该如何选择呢？&lt;br&gt;我们应该尽量使用前自增运算符而不是后自增运算符，即用
        
      
    
    </summary>
    
      <category term="C++" scheme="localhost/categories/C/"/>
    
    
      <category term="C++" scheme="localhost/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++面试题</title>
    <link href="localhost/2024/09/23/thirtyfour/"/>
    <id>localhost/2024/09/23/thirtyfour/</id>
    <published>2024-09-23T14:37:51.000Z</published>
    <updated>2025-05-08T13:41:17.324Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;1.&lt;code&gt;char c = &amp;#39;\72&amp;#39;&lt;/code&gt;;
        
      
    
    </summary>
    
      <category term="C++" scheme="localhost/categories/C/"/>
    
    
      <category term="C++" scheme="localhost/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++细说sizeof</title>
    <link href="localhost/2024/09/08/thirythree/"/>
    <id>localhost/2024/09/08/thirythree/</id>
    <published>2024-09-08T09:46:14.000Z</published>
    <updated>2025-05-13T13:41:49.949Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;摘要：&quot;&gt;&lt;a href=&quot;#摘要：&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="C++" scheme="localhost/categories/C/"/>
    
    
      <category term="C++" scheme="localhost/tags/C/"/>
    
  </entry>
  
</feed>
