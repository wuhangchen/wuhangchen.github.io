<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux 删除大量文件效率对比</title>
      <link href="/2024/07/24/eleven/"/>
      <url>/2024/07/24/eleven/</url>
      
        <content type="html"><![CDATA[<p>首先建立50万个文件</p><pre><code>for i in $(seq 1 500000);do echo text &gt;&gt;$i.txt;done</code></pre><h1 id="rm删除"><a href="#rm删除" class="headerlink" title="rm删除"></a>rm删除</h1><pre><code>time rm -f *zshsure you want to delete all the files in /home/hungerr/test [yn]? yzsh: argument list too long</code></pre><p>total由于文件数量过多，rm不起作用。</p><h1 id="find删除"><a href="#find删除" class="headerlink" title="find删除"></a>find删除</h1><pre><code>time find ./ -type f -exec rm {} \;</code></pre><p>49.86s user 1032.13s system 41% cpu 43:19.17 total大概43分钟,我的电脑。。。。。。边看视频边删的。</p><h1 id="find-with-delete"><a href="#find-with-delete" class="headerlink" title="find with delete"></a>find with delete</h1><pre><code>time find ./ -type f -delete</code></pre><p>0.43s user 11.21s system 2% cpu 9:13.38 total用时9分钟。</p><h1 id="rsync删除"><a href="#rsync删除" class="headerlink" title="rsync删除"></a>rsync删除</h1><p>首先建立空文件夹blanktest</p><pre><code>time rsync -a --delete blanktest/</code></pre><p>0.59s user 7.86s system 51% cpu 16.418 total16s，很好很强大。</p><h1 id="Python删除"><a href="#Python删除" class="headerlink" title="Python删除"></a>Python删除</h1><pre><code>import osimport timeitdef main():    for pathname,dirnames,filenames in os.walk(&#39;/home/username/test&#39;):        for filename in filenames:            file=os.path.join(pathname,filename)            os.remove(file)if __name__==&#39;__main__&#39;:    t=timeit.Timer(&#39;main()&#39;,&#39;from __main__ import main&#39;)    print t.timeit(1)python test.py529.309022903大概用时9分钟。</code></pre><h1 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h1><p>rm：文件数量太多，不可用<br>find with -exec 50万文件耗时43分钟<br>find with -delete 9分钟<br>Python 9分钟<br>rsync with -delete  16s<br>结论：删除大量小文件rsync最快，最方便。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统查找大文件</title>
      <link href="/2024/07/24/ten/"/>
      <url>/2024/07/24/ten/</url>
      
        <content type="html"><![CDATA[<p>在Windows系统中，我们可以使用TreeSize工具查找一些大文件或文件夹，非常的方便高效，在Linux系统中，<br>如何去搜索一些比较大的文件呢？下面我整理了一下在Linux系统中如何查找大文件或文件夹的方法。</p><h1 id="如何查找大文件？"><a href="#如何查找大文件？" class="headerlink" title="如何查找大文件？"></a>如何查找大文件？</h1><p>其实很多时候，你需要了解当前系统下有哪些大文件，比如文件大小超过100M或1G（阀值视具体情况而定）。<br>那么如何把这些大文件搜索出来呢？例如我要搜索当前目录下，超过800M大小的文件<br>如上命令所示，我们仅仅能看到超过800M大小的文件的文件名称，但是对文件的信息（例如，文件大小、文件属性）一无所知，<br>那么能否更详细显示一些文件属性或信息呢如果你还需要对查找结果按照文件大小做一个排序，那么可以使用下面命令</p><pre><code>find . -type f -size +800M  -print0 | xargs -0 du -h | sort -nr</code></pre><h1 id="如何查找Linux下的大目录"><a href="#如何查找Linux下的大目录" class="headerlink" title="如何查找Linux下的大目录"></a>如何查找Linux下的大目录</h1><p>譬如有时候磁盘空间告警了，而你平时又疏于管理、监控文件的增长，那么我需要快速的了解哪些目录变得比较大，<br>那么此时我们可以借助du命令来帮我们解决这个问题。</p><pre><code>du -h --max-depth=1 16K    ./lost+found 33G    ./flash_recovery_area 37G    ./oradata 70G     .</code></pre><p>如果你想知道flash_recovery_area目录下面有哪些大文件夹，那么可以将参数max-depth=2 ，如果你想对搜索出来的结果进行排序，<br>那么可以借助于sort命令。如下所示</p><pre><code>du -h --max-depth=2 | sort -n</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 终端诡异家伙</title>
      <link href="/2024/07/24/nine/"/>
      <url>/2024/07/24/nine/</url>
      
        <content type="html"><![CDATA[<p>这篇文章，我们一起来到 Linux 的诡异的一面……你知道吗？在我们日常使用的 Unix（和 Linux ）及其各种各样的分支系统中，<br>存在着一些诡异的命令或进程，它们让人毛骨悚然，有些确实是有害，但也有些却是有益的。下面就来简单介绍一下这些家伙吧。</p><h1 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h1><p>daemon 有一个很高大上的中文名字，叫守护进程 。有句话是这么说的，如果 Unix 中没有了守护进程，那么 Unix 就不会是相同的。<br>它很有个性，是一个运行在后台且不受终端控制的进程，其大多数都是随着系统启动而启动，无特殊情况下会一直保持运行直到系统关闭。<br>它的存在为我们用户和系统本身提供有用的服务。常见的有 httpd，mysqld，syslogd 等，一般守护程序名称会以  d 结尾。</p><h1 id="zombie"><a href="#zombie" class="headerlink" title="zombie"></a>zombie</h1><p>zombie ，僵尸？什么鬼？听着就让人害怕。不过，它在 Linux 中指的是当一个进程被杀死后，其实它并不会马上消失，<br>而是变成了 zombie ，即僵尸进程，然后等待其父进程搜集完它的信息才会被清除。一般这种搜集信息的过程会很快完成，<br>但有时它的父进程很忙，该僵尸进程就会一直呆在我们的系统中。系统运行过程中时不时地会产生一些僵尸进程，我们无法直接杀死它们，<br>因为它们已经死了，我们只能采取别的手段，比如说杀死它的父进程，然后由 init 来回收这个僵尸进程。<br>僵尸进程的出现通常表示产生它的进程除了问题，而且它会消耗资源，要防止它的出现。</p><h1 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h1><p>kill ，一个冷酷无情的单词。顾名思义，kill 是一个用于杀死进程的命令，其使用方法简单粗暴。<br>当你发现一个占用太多内存或者 CPU 资源的进程并造成了负面影响时，建议您可以直接用 kill 干掉它。<br>若你遇到僵尸进程杀不掉？别慌，去找它的父进程吧，按上面提到的方法来处理。</p><h1 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h1><p>cat，猫？这又是什么奇怪的东西？Linux中除了僵尸还有猫？其实，cat 命令是 concatenate 的简写，也就是连接的意思，<br>这么解释你就懂了。它的作用是组合文件。另外，你甚至可以用这个方便的命令来查看文件的内容。</p><h1 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h1><p>tail，尾巴。这个怪怪的命令解释起来就比较容易了。当你想要查看文件的最后 n 行时，使用 tail 命令就很方便了。<br>另外，当你想要监控文件时，你也可以用它。比如观察日志文件，tail 命令会显示尾部的内容并且可以实时更新，是不是很厉害呢？</p><h1 id="which"><a href="#which" class="headerlink" title="which"></a>which</h1><p>which，别看了前面几个诡异的命令就和 witch（女巫）搞混了。它不是那种童话中阴森恶毒的女巫，它是 which，<br>是负责打印传递给它的任何命令相关联的文件的位置的家伙。例如，我们想要获取 Python 的位置，我们就可以用 which python ，<br>它就会在你的系统上打印每个版本的 Python 的位置。</p><h1 id="crypt"><a href="#crypt" class="headerlink" title="crypt"></a>crypt</h1><p>crypt，地下室，这个命令也很好懂。当你想要保管好自己的东西不被别人知道，放到地下室锁起来是一个很好的办法。<br>crypt 在 Linux 中的含义是加密，现在被称为 mcrypt ，当你想要对文件进行加密而不被别人读取，这个命令会很方便。<br>与大多数 Linux 命令一样，您可以单独使用 crypt ，也可以在系统脚本中使用。</p><h1 id="shred"><a href="#shred" class="headerlink" title="shred"></a>shred</h1><p>shred，切碎。我想你看到这里已经对这些怪异的词语见怪不怪了。它是个非常狠的家伙，作用是粉碎文件。当我们想要删除文件，<br>我们会用 rm 命令，但这是有手段进行恢复的，那我们不想让别人恢复怎么办？没错，sherd 的作用就此。<br>shred 能多次覆盖文件以前占用的空间。所以说，用这个命令一点要做好心理准备，因为神仙难救。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Make 三连</title>
      <link href="/2024/07/24/eight/"/>
      <url>/2024/07/24/eight/</url>
      
        <content type="html"><![CDATA[<p>Unix 开发过程中，经常性的操作是从源码编译安装相应库文件，所以下面三个命令便是家常便饭，俗称三连：</p><pre><code>./configuremakemake install</code></pre><p>下面来看看这三步分别做了什么。</p><h1 id="configure"><a href="#configure" class="headerlink" title="configure"></a>configure</h1><p>执行 ./configure 文件一般是进行正式编译前的一些环境准备，准备编译需要的依赖项等。比如检测当前的系统平台，<br>检测需要的编译器是否存在如何调用，配置和生成相应编译所需文件。</p><h1 id="make"><a href="#make" class="headerlink" title="make"></a>make</h1><p>前期准备工作完成无误后，就可能调用 make 来执行编译了。实际执行的是 Makefile 文件中定义的任务来从源码进行项目的编译。<br>通常情况下下载下来的 tar 包中可能没有包含正式的 Makefile 文件，而是另外形式呈现的临时文件，<br>比如 Makefile.in，Makefile.am,Makefile.MSVC 等，然后在执行 ./configure 的时候根据相应环境来生成最终需要的 Makefile 文件。</p><h1 id="make-install"><a href="#make-install" class="headerlink" title="make install"></a>make install</h1><p>项目编译正常后，会生成相应的产出，可执行文件，so 或 o 文件或 DLL 动态链接文件等。最后一步就是将生成的文件复制到相应的系统目录，<br>这个过程便是安装。比如将可执行文件复制到系统 PATH 能取到的地方，帮助文档复制到 MANPATH，其他文件复制到对应目录下。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 完全卸载一个软件包</title>
      <link href="/2024/07/23/six/"/>
      <url>/2024/07/23/six/</url>
      
        <content type="html"><![CDATA[<p>今天卸载一个软件，老是有配置残留，网上找到了解决方案：<br>查看已安装的软件：</p><pre><code>dpkg -l |grep 软件名</code></pre><p>找到一大堆相关的包，然后卸载核心的包：</p><pre><code>sudo apt-get remove --purge 软件包名</code></pre><p>继续grep，直到找不到相关的包。<br>最后再来两把：</p><pre><code>sudo apt-get autoremovesudo apt-get clean</code></pre><p>注销一下当前用户再登录 一般就干净了。<br>安装deb：</p><pre><code>sudo dpkg -i xxxxx.deb</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 命令行神器推荐</title>
      <link href="/2024/07/23/five/"/>
      <url>/2024/07/23/five/</url>
      
        <content type="html"><![CDATA[<p>• ag：比grep、ack更快的递归搜索文件内容。<br>• jq: json文件处理以及格式化显示，支持高亮，可以替换python -m json.tool。<br>• ncdu：可视化的空间分析程序<br>你发现有人把 /home 空间撑爆了，影响了大家的工作，你愤怒了一层层的 du，一层层的 cd，整个过程就像刨垃圾堆一样的恶心，后来发现了 ncdu 这个基于 ncurses 的空间分析程序：不但能用光标上下键移动，回车还可以进入对应目录又可以查看最新的占用，很快就揪出了占用空间最大的罪魁祸首。<br>• shellcheck：shell脚本静态检查工具，能够识别语法错误以及不规范的写法。<br>• fzf：命令行下模糊搜索工具，能够交互式智能搜索并选取文件或者内容，配合终端ctrl-r历史命令搜索简直完美。<br>• PathPicker(fpp): 在命令行输出中自动识别目录和文件，支持交互式，配合git非常有用。运行以下命令：<br>git diff HEAD~8 –stat | fpp<br>• htop: 提供更美观、更方便的进程监控工具，替代top命令。<br>• glances：更强大的 htop / top 代替者。htop 代替 top，glances 代替 htop：<br>信息比 htop 丰富了不少，更全了，对吧？除了命令行查看外，glances 还提供页面服务，让你从页面上随时查看某服务器的状态。<br>• axel：多线程下载工具，下载文件时可以替代curl、wget。<br>axel -n 20 <a href="http://centos.ustc.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1511.iso" target="_blank" rel="noopener">http://centos.ustc.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1511.iso</a><br>• sz/rz：交互式文件传输，在多重跳板机下传输文件非常好用，不用一级一级传输。<br>• cloc：代码统计工具，能够统计代码的空行数、注释行、编程语言。<br>• tmux：终端复用工具，替代screen、nohup。<br>• script/scriptreplay:  终端会话录制。<br>// 录制<br>script -t 2&gt;time.txt session.typescript<br>// your commands<br>// 录制结束<br>exit<br>// 回放<br>scriptreplay -t time.txt session.typescript<br>• multitail：多重 tail。通常你不止一个日志文件要监控，怎么办？终端软件里开多个 tab 太占地方，可以试试这个工具：</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux shell变量含义</title>
      <link href="/2024/07/23/four/"/>
      <url>/2024/07/23/four/</url>
      
        <content type="html"><![CDATA[<p>$$               Shell本身的PID（ProcessID）<br>$!               Shell最后运行的后台Process的PID<br>$?               最后运行的命令的结束代码（返回值）<br>$-               使用Set命令设定的Flag一览<br>$<em>               所有参数列表。如”$</em>“用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。<br>$@               所有参数列表。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。<br>$#               添加到Shell的参数个数<br>$0               Shell本身的文件名<br>$1～$n           添加到Shell的各参数值。$1是第1参数、$2是第2参数…。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统目录结构</title>
      <link href="/2024/07/20/three/"/>
      <url>/2024/07/20/three/</url>
      
        <content type="html"><![CDATA[<p>/bin  经常使用的指令<br>/boot 启动linux的核心文件<br>/dev  外部设备<br>/etc  系统管理配置文件和子目录<br>/home  自己的目录<br>/lib  共享动态链接库<br>/lost+found  非法关机后存放文件<br>/media   识别的设备的文件<br>/mnt  临时挂载别的文件系统<br>/opt  主机额外安装软件的目录<br>/proc   虚拟的目录，在内存上而不在硬盘上<br>/root  系统管理员<br>/sbin  系统管理员的系统管理程序<br>/srv  存放服务启动之后需要提取的数据<br>/tmp  存放临时文件<br>/usr  用户的很多应用程序和文件<br>/usr/bin  系统用户使用的应用程序<br>/usr/sbin  超级用户使用的管理程序和系统守护程序<br>/usr/src  内核源代码的目录<br>/var  修改的目录的日志文                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        身的文件数据<br>/var/log     日志文件                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 网络工具</title>
      <link href="/2024/06/29/second/"/>
      <url>/2024/06/29/second/</url>
      
        <content type="html"><![CDATA[<p>如果要在你的系统上监控网络，那么使用命令行工具是非常实用的，并且对于 Linux 用户来说，有着许许多多现成的工具可以使用，<br>如： nethogs, ntopng, nload, iftop, iptraf, bmon, slurm,<br>tcptrack, cbm, netwatch, collectl, trafshow, cacti, etherape, ipband, jnettop, netspeed 以及 speedometer。<br>鉴于世上有着许多的 Linux 专家和开发者，显然还存在其他的网络监控工具，但在教程中，<br>我不打算将它们所有包括在内。<br>上面列出的工具都有着自己的独特之处，但归根结底，它们都做着监控网络流量的工作，<br>只是通过各种不同的方法。例如 nethogs 可以被用来展示每个进程的带宽使用情况，<br>以防你想知道究竟是哪个应用在消耗了你的整个网络资源；</p><pre><code>iftop 可以被用来展示每个套接字连接的带宽使用情况，nload 这类的工具可以帮助你得到有关整个带宽的信息。</code></pre><h1 id="nethogs"><a href="#nethogs" class="headerlink" title="nethogs"></a>nethogs</h1><p>nethogs 是一个免费的工具，当要查找哪个 PID (注：即 process identifier，进程 ID) 给你的网络流量带来了麻烦时，它是非常方便的。<br>它按每个进程来分组带宽，而不是像大多数的工具那样按照每个协议或每个子网来划分流量。它功能丰富，同时支持 IPv4 和 IPv6，<br>并且我认为，若你想在你的 Linux 主机上确定哪个程序正消耗着你的全部带宽，它是来做这件事的最佳的程序。<br>一个 Linux 用户可以使用 nethogs 来显示每个进程的 TCP 下载和上传速率，可以使用命令 nethogs eth0 来监控一个指定的设备，<br>上面的 eth0 是那个你想获取信息的设备的名称，你还可以得到有关正在传输的数据的传输速率信息。对我而言， nethogs 是非常容易使用的，<br>或许是因为我非常喜欢它，以至于我总是在我的 Ubuntu 12.04 LTS 机器中使用它来监控我的网络带宽。例如要想使用混杂模式来嗅探，<br>可以像下面展示的命令那样使用选项 -p：</p><pre><code>nethogs -p wlan0</code></pre><p>假如你想更多地了解 nethogs 并深入探索它，那么请毫不犹豫地阅读我们做的关于这个网络带宽监控工具的整个教程。</p><h1 id="nload"><a href="#nload" class="headerlink" title="nload"></a>nload</h1><p>nload 是一个控制台应用，可以被用来实时地监控网络流量和带宽使用情况，它还通过提供两个简单易懂的图表来对流量进行可视化。<br>这个绝妙的网络监控工具还可以在监控过程中切换被监控的设备，而这可以通过按左右箭头来完成。<br>正如你在上面的截图中所看到的那样，由 nload 提供的图表是非常容易理解的。nload 提供了有用的信息，<br>也展示了诸如被传输数据的总量和最小/最大网络速率等信息。而更酷的是你只需要直接运行 nload 这个工具就行，这个命令是非常的短小且易记的：</p><h1 id="slurm"><a href="#slurm" class="headerlink" title="slurm"></a>slurm</h1><p>slurm 是另一个 Linux 网络负载监控工具，它以一个不错的 ASCII 图来显示结果，它还支持许多按键用以交互，例如 c 用来切换到经典模式，<br>s 切换到分图模式， r 用来重绘屏幕， L 用来启用 TX/RX 灯（注：TX，发送流量；RX，接收流量） ，<br>m 用来在经典分图模式和大图模式之间进行切换， q 退出 slurm。在网络负载监控工具 slurm 中，还有许多其它的按键可用，<br>你可以很容易地使用下面的命令在 man 手册中学习它们。</p><pre><code>man slurm</code></pre><p>slurm 在 Ubuntu 和 Debian 的官方软件仓库中可以找到，所以使用这些发行版本的用户可以像下面展示的那样，<br>使用 apt-get 安装命令来轻松地下载它：</p><pre><code>sudo apt-get install slurm</code></pre><p>我们已经在一个教程中对 slurm 的使用做了介绍，不要忘记和其它使用 Linux 的朋友分享这些知识。</p><h1 id="iftop"><a href="#iftop" class="headerlink" title="iftop"></a>iftop</h1><p>当你想显示连接到网卡上的各个主机的带宽使用情况时，iftop 是一个非常有用的工具。根据 man 手册，<br>iftop 在一个指定的接口或在它可以找到的第一个接口（假如没有任何特殊情况，它应该是一个对外的接口）上监听网络流量，<br>并且展示出一个表格来显示当前的一对主机间的带宽使用情况。<br>通过在虚拟终端中使用下面的命令，Ubuntu 和 Debian 用户可以在他们的机器中轻易地安装 iftop：</p><pre><code>sudo apt-get install iftop</code></pre><h1 id="collectl"><a href="#collectl" class="headerlink" title="collectl"></a>collectl</h1><p>collectl 可以被用来收集描述当前系统状态的数据，并且它支持如下两种模式：<br>记录模式<br>回放模式<br>记录模式 允许从一个正在运行的系统中读取数据，然后将这些数据要么显示在终端中，要么写入一个或多个文件或一个套接字中。<br>回放模式<br>根据 man 手册，在这种模式下，数据从一个或多个由记录模式生成的数据文件中读取。<br>Ubuntu 和 Debian 用户可以在他们的机器上使用他们默认的包管理器来安装 colletcl。下面的命令将为他们做这个工作：</p><pre><code>sudo apt-get install collectl</code></pre><h1 id="Netstat"><a href="#Netstat" class="headerlink" title="Netstat"></a>Netstat</h1><p>Netstat 是一个用来监控传入和传出的网络数据包统计数据的接口统计数据命令行工具。<br>它会显示 TCP 连接 (包括上传和下行)，路由表，及一系列的网络接口（网卡或者SDN接口）和网络协议统计数据。<br>Ubuntu 和 Debian 用户可以在他们的机器上使用默认的包管理器来安装 netstat。<br>Netstat 软件被包括在 net-tools 软件包中，并可以在 shell 或虚拟终端中运行下面的命令来安装它：</p><pre><code>sudo apt-get install net-toolsnetstat</code></pre><p>更多的关于 netstat 的信息，我们可以简单地在 shell 或终端中键入 man netstat 来了解：<br>man netstat</p><h1 id="Netload"><a href="#Netload" class="headerlink" title="Netload"></a>Netload</h1><p>netload 命令只展示一个关于当前网络荷载和自从程序运行之后传输数据总的字节数目的简要报告，它没有更多的功能。<br>它是 netdiag 软件的一部分。<br>Netload 是默认仓库中 netdiag 的一部分，我们可以轻易地使用下面的命令来利用 apt 包管理器安装 netdiag：</p><pre><code>sudo apt-get install netdiag</code></pre><p>为了运行 netload，我们需要确保选择了一个正在工作的网络接口的名称，<br>如 eth0, eh1, wlan0, mon0等，然后在 shell 或虚拟终端中运行下面的命令：</p><pre><code>netload wlan2</code></pre><p>注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，假如你想通过扫描了解你的网络接口名称，<br>可以在一个虚拟终端或 shell 中运行 <code>ip link show</code>命令。</p><h1 id="Nagios"><a href="#Nagios" class="headerlink" title="Nagios"></a>Nagios</h1><p>Nagios 是一个领先且功能强大的开源监控系统，它使得网络或系统管理员可以在服务器的各种问题影响到服务器的主要事务之前，<br>发现并解决这些问题。 有了 Nagios 系统，管理员便可以在一个单一的窗口中监控远程的 Linux 、Windows 系统、交换机、路由器和打印机等。<br>它会显示出重要的警告并指出在你的网络或服务器中是否出现某些故障，这可以间接地帮助你在问题发生前就着手执行补救行动。<br>Nagios 有一个 web 界面，其中有一个图形化的活动监视器。通过浏览网页 <a href="http://localhost/nagios/">http://localhost/nagios/</a> 或 <a href="http://localhost/nagios3/">http://localhost/nagios3/</a> 便可以登录到这个 web 界面。<br>假如你在远程的机器上进行操作，请使用你的 IP 地址来替换 localhost，然后键入用户名和密码，我们便会看到如下图所展示的信息：</p><h1 id="EtherApe"><a href="#EtherApe" class="headerlink" title="EtherApe"></a>EtherApe</h1><p>EtherApe 是一个针对 Unix 的图形化网络监控工具，它仿照了 etherman 软件。它支持链路层、IP 和 TCP 等模式，<br>并支持以太网, FDDI, 令牌环, ISDN, PPP, SLIP 及 WLAN 设备等接口，以及一些封装格式。<br>主机和连接随着流量和协议而改变其尺寸和颜色。它可以过滤要展示的流量，并可从一个文件或运行的网络中读取数据包。<br>我们也可以使用下面的命令在 Ubuntu、Debian 及它们的衍生发行版本中使用 apt 包管理器来安装 EtherApe ：</p><pre><code>sudo apt-get install etherape</code></pre><p>在 EtherApe 安装到你的系统之后，我们需要像下面那样以 root 权限来运行 etherape：</p><pre><code>sudo etherape</code></pre><p>然后， etherape 的 图形用户界面 便会被执行。接着，在菜单上面的 捕捉 选项下，我们可以选择 模式(IP，链路层，TCP) 和 接口。<br>一切设定完毕后，我们需要点击 开始 按钮。接着我们便会看到类似下面截图的东西：</p><h1 id="tcpflow"><a href="#tcpflow" class="headerlink" title="tcpflow"></a>tcpflow</h1><p>tcpflow 是一个命令行工具，它可以捕捉 TCP 连接(流)的部分传输数据，并以一种方便协议分析或除错的方式来存储数据。<br>它重构了实际的数据流并将每个流存储在不同的文件中，以备日后的分析。它能识别 TCP 序列号并可以正确地重构数据流，不管是在重发还是乱序发送状态下。<br>通过 apt 包管理器在 Ubuntu 、Debian 系统中安装 tcpflow 是很容易的，因为默认情况下在官方软件仓库中可以找到它。</p><pre><code>sudo apt-get install tcpflow</code></pre><p>我们可以使用 tcpflow 来捕捉全部或部分 tcp 流量，并以一种简单的方式把它们写到一个可读的文件中。下面的命令就可以完成这个事情，但我们需要在一个空目录中运行下面的命令，因为它将创建诸如 x.x.x.x.y-a.a.a.a.z 格式的文件，运行之后，只需按 Ctrl-C 便可停止这个命令。</p><pre><code>sudo tcpflow -i eth0 port 8000</code></pre><p>注意：请将上面的 eth0 替换为你想捕捉的网卡接口名称</p><h1 id="IPTraf"><a href="#IPTraf" class="headerlink" title="IPTraf"></a>IPTraf</h1><p>IPTraf 是一个针对 Linux 平台的基于控制台的网络统计应用。它生成一系列的图形，如 TCP 连接的包/字节计数、接口信息和活动指示器、<br>TCP/UDP 流量故障以及局域网内设备的包/字节计数。<br>在默认的软件仓库中可以找到 IPTraf，所以我们可以使用下面的命令通过 apt 包管理器轻松地安装 IPTraf：</p><pre><code>sudo apt-get install iptraf</code></pre><p>我们需要以管理员权限来运行 IPTraf，并带有一个有效的网络接口名。这里，我们的网络接口名为 wlan2，所以我们使用 wlan2 来作为参数：</p><pre><code>sudo iptraf wlan2</code></pre><p>开始通常的网络接口统计，键入：</p><pre><code>iptraf -g查看接口 eth0 的详细统计信息，使用：iptraf -d eth0查看接口 eth0 的 TCP 和 UDP 监控信息，使用：iptraf -z eth0查看接口 eth0 的包的大小和数目，使用：iptraf -z eth0</code></pre><p>注意:请将上面的 eth0 替换为你的接口名称。你可以通过运行ip link show命令来检查你的接口。</p><h1 id="Speedometer"><a href="#Speedometer" class="headerlink" title="Speedometer"></a>Speedometer</h1><p>Speedometer 是一个小巧且简单的工具，它只用来绘出一幅包含有通过某个给定端口的上行、下行流量的好看的图。<br>我们可以使用下面的命令通过 apt 包管理器轻松地安装 Speedometer：</p><pre><code>sudo apt-get install speedometerSpeedometer 可以简单地通过在 shell 或虚拟终端中执行下面的命令来运行：speedometer -r wlan2 -t wlan2</code></pre><p>注：请将上面的 wlan2 替换为你想要使用的网络接口名称</p><h1 id="Netwatch"><a href="#Netwatch" class="headerlink" title="Netwatch"></a>Netwatch</h1><p>Netwatch 是 netdiag 工具集里的一部分，它也显示当前主机和其他远程主机的连接情况，以及在每个连接中数据传输的速率。<br>Netwatch 是 netdiag 的一部分，可以在默认的软件仓库中找到，所以我们可以轻松地使用下面的命令来利用 apt 包管理器安装netdiag：</p><pre><code>sudo apt-get install netdiag</code></pre><p>为了运行 netwatch， 我们需要在虚拟终端或 shell 中执行下面的命令：</p><pre><code>sudo netwatch -e wlan2 -nt</code></pre><p>注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，假如你想通过扫描了解你的网络接口名称，<br>可以在一个虚拟终端或 shell 中运行 ip link show 命令。</p><h1 id="Trafshow"><a href="#Trafshow" class="headerlink" title="Trafshow"></a>Trafshow</h1><p>Trafshow 同 netwatch 和 pktstat 一样，可以报告当前活动的连接里使用的协议和每个连接中数据传输的速率。<br>它可以使用 pcap 类型的过滤器来筛选出特定的连接。<br>Trafshow 在默认仓库中可以找到，所以我们可以轻松地使用下面的命令来利用 apt 包管理器安装它：</p><pre><code>sudo apt-get install trafshow</code></pre><p>为了使用 trafshow 来执行监控任务，我们需要在虚拟终端或 shell 中执行下面的命令：</p><pre><code>sudo trafshow -i wlan2</code></pre><p>为了专门监控 tcp 连接，如下面一样添加上 tcp 参数：</p><pre><code>sudo trafshow -i wlan2 tcp</code></pre><p>注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，假如你想通过扫描了解你的网络接口名称，可以在一个虚拟终端或 shell 中运行 ip link show 命令。</p><h1 id="Vnstat"><a href="#Vnstat" class="headerlink" title="Vnstat"></a>Vnstat</h1><p>与大多数的其他工具相比，Vnstat 有一点不同。实际上它运行着一个后台服务或守护进程，并时刻记录着传输数据的大小。<br>另外，它可以被用来生成一个网络使用历史记录的报告。<br>Vnstat 在默认软件仓库中可以找到，所以我们可以使用下面的命令运行 apt 包管理器来安装它：</p><pre><code>sudo apt-get install vnstat</code></pre><p>不带有任何选项运行 vnstat 将简单地展示出从该守护进程运行后数据传输的总量。</p><pre><code>vnstatvnstat -l</code></pre><p>为实时地监控带宽使用情况，使用 ‘-l’ 选项(live 模式)。然后它将以一种非常精确的方式来展示上行和下行数据所使用的带宽总量，但不会显示任何有关主机连接或进程的内部细节。<br>完成了上面的步骤后，按 Ctrl-C 来停止，这将会得到如下类型的输出</p><h1 id="tcptrack"><a href="#tcptrack" class="headerlink" title="tcptrack"></a>tcptrack</h1><p>tcptrack 可以展示 TCP 连接的状态，它在一个给定的网络端口上进行监听。tcptrack 监控它们的状态并展示出排序且不断更新的列表，<br>包括来源/目标地址、带宽使用情况等信息，这与 top 命令的输出非常类似 。<br>鉴于 tcptrack 在软件仓库中，我们可以轻松地在 Debian、Ubuntu 系统中从软件仓库使用 apt 包管理器来安装 tcptrack。<br>为此，我们需要在 shell 或虚拟终端中执行下面的命令：</p><pre><code>sudo apt-get install tcptrack</code></pre><p>tcptrack 需要以 root 权限或超级用户身份来运行。执行 tcptrack 时，我们需要带上要监视的网络接口 TCP 连接状况的接口名称。这里我们的接口名称为 wlan2，所以如下面这样使用：</p><pre><code>sudo tcptrack -i wlan2</code></pre><p>假如你想监控特定的端口，则使用：</p><pre><code>tcptrack -i wlan2 port 80</code></pre><p>请替换上面的 80 为你想要监控的端口号。注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，<br>假如你想通过扫描了解你的网络接口名称，可以在一个虚拟终端或 shell 中运行 ip link show 命令。</p><h1 id="CBM"><a href="#CBM" class="headerlink" title="CBM"></a>CBM</h1><p>CBM （ Color Bandwidth Meter） 可以展示出当前所有网络设备的流量使用情况。这个程序是如此的简单，<br>以至于都可以从它的名称中看出其功能。CBM 的源代码和新版本可以在 <a href="http://www.isotton.com/utils/cbm/" target="_blank" rel="noopener">http://www.isotton.com/utils/cbm/</a> 上找到。<br>鉴于 CBM 已经包含在软件仓库中，我们可以简单地使用 apt 包管理器从 Debian、Ubuntu 的软件仓库中安装 CBM。<br>为此，我们需要在一个 shell 窗口或虚拟终端中运行下面的命令：</p><pre><code>sudo apt-get install cbm</code></pre><p>我们只需使用下面展示的命令来在 shell 窗口或虚拟终端中运行 cbm：</p><pre><code>cbm</code></pre><h1 id="bmon"><a href="#bmon" class="headerlink" title="bmon"></a>bmon</h1><p>Bmon （ Bandwidth Monitoring） ，是一个用于调试和实时监控带宽的工具。这个工具能够检索各种输入模块的统计数据。<br>它提供了多种输出方式，包括一个基于 curses 库的界面，轻量级的HTML输出，以及 ASCII 输出格式<br>bmon 可以在软件仓库中找到，所以我们可以通过使用 apt 包管理器来在 Debian、Ubuntu 中安装它。<br>为此，我们需要在一个 shell 窗口或虚拟终端中运行下面的命令：</p><pre><code>sudo apt-get install bmon</code></pre><p>我们可以使用下面的命令来运行 bmon 以监视我们的网络状态：</p><pre><code>bmon</code></pre><h1 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h1><p>TCPDump 是一个用于网络监控和数据获取的工具。它可以为我们节省很多的时间，并可用来调试网络或服务器的相关问题。<br>它可以打印出在某个网络接口上与布尔表达式相匹配的数据包所包含的内容的一个描述。<br>tcpdump 可以在 Debian、Ubuntu 的默认软件仓库中找到，我们可以简单地以 sudo 权限使用 apt 包管理器来安装它。<br>为此，我们需要在一个 shell 窗口或虚拟终端中运行下面的命令：</p><pre><code>sudo apt -get install tcpdump</code></pre><p>tcpdump 也可以在 Fedora、CentOS、RHEL 的软件仓库中找到。我们可以像下面一样通过 yum 包管理器来安装它：<br>tcpdump 需要以 root 权限或超级用户来运行，我们需要带上我们想要监控的 TCP 连接的网络接口名称来执行 tcpdump 。在这里，<br>我们有 wlan2 这个网络接口，所以可以像下面这样使用：</p><pre><code>sudo tcpdump -i wlan2</code></pre><p>假如你只想监视一个特定的端口，则可以运行下面的命令。下面是一个针对 80 端口(网络服务器)的例子：</p><pre><code>sudo tcpdump -i wlan2 &#39;port 80&#39;</code></pre><h1 id="ntopng"><a href="#ntopng" class="headerlink" title="ntopng"></a>ntopng</h1><p>ntopng 是 ntop 的下一代版本。它是一个用于展示网络使用情况的网络探头，在一定程度上它与 top 针对进程所做的工作类似。<br>ntopng 基于 libpcap 并且它以可移植的方式被重写，以达到可以在每一个 Unix 平台 、 MacOSX 以及 Win32 上运行的目的。<br>为了在 Debian，Ubuntu 系统上安装 ntopng，首先我们需要安装 编译 ntopng 所需的依赖软件包。<br>你可以通过在一个 shell 窗口或一个虚拟终端中运行下面的命令来安装它们：</p><pre><code>sudo apt-get install libpcap-dev libglib2.0-dev libgeoip-dev redis-server wget libxml2-dev build-essential checkinstall</code></pre><p>现在，我们需要像下面一样针对我们的系统手动编译 ntopng ：</p><pre><code>sudo wget http://sourceforge.net/projects/ntop/files/ntopng/ntopng-1.1_6932.tgz/downloadsudo tar zxfv ntopng-1.1_6932.tgzsudo cd ntopng-1.1_6932sudo ./configuresudo makesudo make install</code></pre><p>这样，在你的 Debian 或 Ubuntu 系统上应该已经安装上了你编译的 ntopng 。<br>我们已经有了有关 ntopng 的使用方法的教程，它既可以在命令行也可以在 Web 界面中使用，<br>我们可以前往这些教程来获得有关 ntopng 的知识。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随想</title>
      <link href="/2023/11/10/first/"/>
      <url>/2023/11/10/first/</url>
      
        <content type="html"><![CDATA[<p>灵魂困于方寸之地, 枷锁桎梏自由之身。</p>]]></content>
      
      
      <categories>
          
          <category> thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thinking </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
